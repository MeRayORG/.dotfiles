Use these functions and fix the project after



lib.fileset: file set functions
lib.fileset.toSource

Type:

toSource :: {
  root :: Path,
  fileset :: FileSet,
} -> SourceLike

Add the local files contained in fileset to the store as a single store path rooted at root.

The result is the store path as a string-like value, making it usable e.g. as the src of a derivation, or in string interpolation:

stdenv.mkDerivation {
  src = lib.fileset.toSource { ... };
  # ...
}

The name of the store path is always source.

structured function argument

: root

    (required) The local directory path that will correspond to the root of the resulting store path. Paths in strings, including Nix store paths, cannot be passed as root. root has to be a directory.

Note

Changing root only affects the directory structure of the resulting store path, it does not change which files are added to the store. The only way to change which files get added to the store is by changing the fileset attribute.

fileset

    (required) The file set whose files to import into the store. Currently the only way to construct file sets is using implicit coercion from paths. If a directory does not recursively contain any file, it is omitted from the store path contents.

Example

lib.fileset.toSource usage example

# Import the current directory into the store but only include files under ./src
toSource { root = ./.; fileset = ./src; }
=> "/nix/store/...-source"

# The file set coerced from path ./bar could contain files outside the root ./foo, which is not allowed
toSource { root = ./foo; fileset = ./bar; }
=> <error>

# The root has to be a local filesystem path
toSource { root = "/nix/store/...-source"; fileset = ./.; }
=> <error>

Located at lib/fileset/default.nix:66 in <nixpkgs>.




lib.fixedPoints: explicit recursion functions
lib.fixedPoints.fix

Type:

fix :: (a -> a) -> a

See https://en.wikipedia.org/wiki/Fixed-point_combinator for further
details.

Compute the fixed point of the given function f, which is usually an attribute set that expects its final, non-recursive representation as an argument:

f = self: { foo = "foo"; bar = "bar"; foobar = self.foo + self.bar; }

Nix evaluates this recursion until all references to self have been resolved. At that point, the final result is returned and f x = x holds:

nix-repl> fix f
{ bar = "bar"; foo = "foo"; foobar = "foobar"; }

f

    Function argument

Located at lib/fixed-points.nix:25 in <nixpkgs>.
lib.fixedPoints.fix'

A variant of fix that records the original recursive attribute set in the result, in an attribute named __unfix__.

This is useful in combination with the extends function to implement deep overriding.

f

    Function argument

Located at lib/fixed-points.nix:34 in <nixpkgs>.
lib.fixedPoints.converge

Type: (a -> a) -> a -> a

Return the fixpoint that f converges to when called iteratively, starting with the input x.

nix-repl> converge (x: x / 2) 16
0

f

    Function argument

x

    Function argument

Located at lib/fixed-points.nix:47 in <nixpkgs>.
lib.fixedPoints.extends

Modify the contents of an explicitly recursive attribute set in a way that honors self-references. This is accomplished with a function

g = self: super: { foo = super.foo + " + "; }

that has access to the unmodified input (super) as well as the final non-recursive representation of the attribute set (self). extends differs from the native // operator insofar as that it's applied before references to self are resolved:

nix-repl> fix (extends g f)
{ bar = "bar"; foo = "foo + "; foobar = "foo + bar"; }

The name of the function is inspired by object-oriented inheritance, i.e. think of it as an infix operator g extends f that mimics the syntax from Java. It may seem counter-intuitive to have the "base class" as the second argument, but it's nice this way if several uses of extends are cascaded.

To get a better understanding how extends turns a function with a fix point (the package set we start with) into a new function with a different fix point (the desired packages set) lets just see, how extends g f unfolds with g and f defined above:

extends g f = self: let super = f self; in super // g self super;
            = self: let super = { foo = "foo"; bar = "bar"; foobar = self.foo + self.bar; }; in super // g self super
            = self: { foo = "foo"; bar = "bar"; foobar = self.foo + self.bar; } // g self { foo = "foo"; bar = "bar"; foobar = self.foo + self.bar; }
            = self: { foo = "foo"; bar = "bar"; foobar = self.foo + self.bar; } // { foo = "foo" + " + "; }
            = self: { foo = "foo + "; bar = "bar"; foobar = self.foo + self.bar; }

f

    Function argument

rattrs

    Function argument

self

    Function argument

Located at lib/fixed-points.nix:91 in <nixpkgs>.
lib.fixedPoints.composeExtensions

Compose two extending functions of the type expected by 'extends' into one where changes made in the first are available in the 'super' of the second

f

    Function argument

g

    Function argument

final

    Function argument

prev

    Function argument

Located at lib/fixed-points.nix:98 in <nixpkgs>.
lib.fixedPoints.composeManyExtensions

Compose several extending functions of the type expected by 'extends' into one where changes made in preceding functions are made available to subsequent ones.

composeManyExtensions : [packageSet -> packageSet -> packageSet] -> packageSet -> packageSet -> packageSet
                          ^final        ^prev         ^overrides     ^final        ^prev         ^overrides

Located at lib/fixed-points.nix:114 in <nixpkgs>.
lib.fixedPoints.makeExtensible

Create an overridable, recursive attribute set. For example:

nix-repl> obj = makeExtensible (self: { })

nix-repl> obj
{ __unfix__ = «lambda»; extend = «lambda»; }

nix-repl> obj = obj.extend (self: super: { foo = "foo"; })

nix-repl> obj
{ __unfix__ = «lambda»; extend = «lambda»; foo = "foo"; }

nix-repl> obj = obj.extend (self: super: { foo = super.foo + " + "; bar = "bar"; foobar = self.foo + self.bar; })

nix-repl> obj
{ __unfix__ = «lambda»; bar = "bar"; extend = «lambda»; foo = "foo + "; foobar = "foo + bar"; }

Located at lib/fixed-points.nix:137 in <nixpkgs>.
lib.fixedPoints.makeExtensibleWithCustomName

Same as makeExtensible but the name of the extending attribute is customized.

extenderName

    Function argument

rattrs

    Function argument

Located at lib/fixed-points.nix:143 in <nixpkgs>.



lib.strings: string manipulation functions
lib.strings.concatStrings

Type: concatStrings :: [string] -> string

Concatenate a list of strings.
Example

lib.strings.concatStrings usage example

concatStrings ["foo" "bar"]
=> "foobar"

Located at lib/strings.nix:50 in <nixpkgs>.
lib.strings.concatMapStrings

Type: concatMapStrings :: (a -> string) -> [a] -> string

Map a function over a list and concatenate the resulting strings.

f

    Function argument

list

    Function argument

Example

lib.strings.concatMapStrings usage example

concatMapStrings (x: "a" + x) ["foo" "bar"]
=> "afooabar"

Located at lib/strings.nix:60 in <nixpkgs>.
lib.strings.concatImapStrings

Type: concatImapStrings :: (int -> a -> string) -> [a] -> string

Like concatMapStrings except that the f functions also gets the position as a parameter.

f

    Function argument

list

    Function argument

Example

lib.strings.concatImapStrings usage example

concatImapStrings (pos: x: "${toString pos}-${x}") ["foo" "bar"]
=> "1-foo2-bar"

Located at lib/strings.nix:71 in <nixpkgs>.
lib.strings.intersperse

Type: intersperse :: a -> [a] -> [a]

Place an element between each element of a list

separator

    Separator to add between elements

list

    Input list

Example

lib.strings.intersperse usage example

intersperse "/" ["usr" "local" "bin"]
=> ["usr" "/" "local" "/" "bin"].

Located at lib/strings.nix:81 in <nixpkgs>.
lib.strings.concatStringsSep

Type: concatStringsSep :: string -> [string] -> string

Concatenate a list of strings with a separator between each element
Example

lib.strings.concatStringsSep usage example

concatStringsSep "/" ["usr" "local" "bin"]
=> "usr/local/bin"

Located at lib/strings.nix:98 in <nixpkgs>.
lib.strings.concatMapStringsSep

Type: concatMapStringsSep :: string -> (a -> string) -> [a] -> string

Maps a function over a list of strings and then concatenates the result with the specified separator interspersed between elements.

sep

    Separator to add between elements

f

    Function to map over the list

list

    List of input strings

Example

lib.strings.concatMapStringsSep usage example

concatMapStringsSep "-" (x: toUpper x)  ["foo" "bar" "baz"]
=> "FOO-BAR-BAZ"

Located at lib/strings.nix:111 in <nixpkgs>.
lib.strings.concatImapStringsSep

Type: concatIMapStringsSep :: string -> (int -> a -> string) -> [a] -> string

Same as concatMapStringsSep, but the mapping function additionally receives the position of its argument.

sep

    Separator to add between elements

f

    Function that receives elements and their positions

list

    List of input strings

Example

lib.strings.concatImapStringsSep usage example

concatImapStringsSep "-" (pos: x: toString (x / pos)) [ 6 6 6 ]
=> "6-3-2"

Located at lib/strings.nix:128 in <nixpkgs>.
lib.strings.concatLines

Type: concatLines :: [string] -> string

Concatenate a list of strings, adding a newline at the end of each one. Defined as concatMapStrings (s: s + "\n").
Example

lib.strings.concatLines usage example

concatLines [ "foo" "bar" ]
=> "foo\nbar\n"

Located at lib/strings.nix:145 in <nixpkgs>.
lib.strings.makeSearchPath

Type: makeSearchPath :: string -> [string] -> string

Construct a Unix-style, colon-separated search path consisting of the given subDir appended to each of the given paths.

subDir

    Directory name to append

paths

    List of base paths

Example

lib.strings.makeSearchPath usage example

makeSearchPath "bin" ["/root" "/usr" "/usr/local"]
=> "/root/bin:/usr/bin:/usr/local/bin"
makeSearchPath "bin" [""]
=> "/bin"

Located at lib/strings.nix:158 in <nixpkgs>.
lib.strings.makeSearchPathOutput

Type: string -> string -> [package] -> string

Construct a Unix-style search path by appending the given subDir to the specified output of each of the packages. If no output by the given name is found, fallback to .out and then to the default.

output

    Package output to use

subDir

    Directory name to append

pkgs

    List of packages

Example

lib.strings.makeSearchPathOutput usage example

makeSearchPathOutput "dev" "bin" [ pkgs.openssl pkgs.zlib ]
=> "/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev/bin:/nix/store/wwh7mhwh269sfjkm6k5665b5kgp7jrk2-zlib-1.2.8/bin"

Located at lib/strings.nix:176 in <nixpkgs>.
lib.strings.makeLibraryPath

Construct a library search path (such as RPATH) containing the libraries for a set of packages
Example

lib.strings.makeLibraryPath usage example

makeLibraryPath [ "/usr" "/usr/local" ]
=> "/usr/lib:/usr/local/lib"
pkgs = import <nixpkgs> { }
makeLibraryPath [ pkgs.openssl pkgs.zlib ]
=> "/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r/lib:/nix/store/wwh7mhwh269sfjkm6k5665b5kgp7jrk2-zlib-1.2.8/lib"

Located at lib/strings.nix:194 in <nixpkgs>.
lib.strings.makeBinPath

Construct a binary search path (such as $PATH) containing the binaries for a set of packages.
Example

lib.strings.makeBinPath usage example

makeBinPath ["/root" "/usr" "/usr/local"]
=> "/root/bin:/usr/bin:/usr/local/bin"

Located at lib/strings.nix:203 in <nixpkgs>.
lib.strings.normalizePath

Type: normalizePath :: string -> string

Normalize path, removing extraneous /s

s

    Function argument

Example

lib.strings.normalizePath usage example

normalizePath "/a//b///c/"
=> "/a/b/c/"

Located at lib/strings.nix:213 in <nixpkgs>.
lib.strings.optionalString

Type: optionalString :: bool -> string -> string

Depending on the boolean `cond', return either the given string or the empty string. Useful to concatenate against a bigger string.

cond

    Condition

string

    String to return if condition is true

Example

lib.strings.optionalString usage example

optionalString true "some-string"
=> "some-string"
optionalString false "some-string"
=> ""

Located at lib/strings.nix:239 in <nixpkgs>.
lib.strings.hasPrefix

Type: hasPrefix :: string -> string -> bool

Determine whether a string has given prefix.

pref

    Prefix to check for

str

    Input string

Example

lib.strings.hasPrefix usage example

hasPrefix "foo" "foobar"
=> true
hasPrefix "foo" "barfoo"
=> false

Located at lib/strings.nix:255 in <nixpkgs>.
lib.strings.hasSuffix

Type: hasSuffix :: string -> string -> bool

Determine whether a string has given suffix.

suffix

    Suffix to check for

content

    Input string

Example

lib.strings.hasSuffix usage example

hasSuffix "foo" "foobar"
=> false
hasSuffix "foo" "barfoo"
=> true

Located at lib/strings.nix:282 in <nixpkgs>.
lib.strings.hasInfix

Type: hasInfix :: string -> string -> bool

Determine whether a string contains the given infix

infix

    Function argument

content

    Function argument

Example

lib.strings.hasInfix usage example

hasInfix "bc" "abcd"
=> true
hasInfix "ab" "abcd"
=> true
hasInfix "cd" "abcd"
=> true
hasInfix "foo" "abcd"
=> false

Located at lib/strings.nix:319 in <nixpkgs>.
lib.strings.stringToCharacters

Type: stringToCharacters :: string -> [string]

Convert a string to a list of characters (i.e. singleton strings). This allows you to, e.g., map a function over each character. However, note that this will likely be horribly inefficient; Nix is not a general purpose programming language. Complex string manipulations should, if appropriate, be done in a derivation. Also note that Nix treats strings as a list of bytes and thus doesn't handle unicode.

s

    Function argument

Example

lib.strings.stringToCharacters usage example

stringToCharacters ""
=> [ ]
stringToCharacters "abc"
=> [ "a" "b" "c" ]
stringToCharacters "🦄"
=> [ "�" "�" "�" "�" ]

Located at lib/strings.nix:349 in <nixpkgs>.
lib.strings.stringAsChars

Type: stringAsChars :: (string -> string) -> string -> string

Manipulate a string character by character and replace them by strings before concatenating the results.

f

    Function to map over each individual character

s

    Input string

Example

lib.strings.stringAsChars usage example

stringAsChars (x: if x == "a" then "i" else x) "nax"
=> "nix"

Located at lib/strings.nix:361 in <nixpkgs>.
lib.strings.charToInt

Type: charToInt :: string -> int

Convert char to ascii value, must be in printable range

c

    Function argument

Example

lib.strings.charToInt usage example

charToInt "A"
=> 65
charToInt "("
=> 40

Located at lib/strings.nix:380 in <nixpkgs>.
lib.strings.escape

Type: escape :: [string] -> string -> string

Escape occurrence of the elements of list in string by prefixing it with a backslash.

list

    Function argument

Example

lib.strings.escape usage example

escape ["(" ")"] "(foo)"
=> "\\(foo\\)"

Located at lib/strings.nix:391 in <nixpkgs>.
lib.strings.escapeC

Type: escapeC = [string] -> string -> string

Escape occurrence of the element of list in string by converting to its ASCII value and prefixing it with \x. Only works for printable ascii characters.

list

    Function argument

Example

lib.strings.escapeC usage example

escapeC [" "] "foo bar"
=> "foo\\x20bar"

Located at lib/strings.nix:404 in <nixpkgs>.
lib.strings.escapeURL

Type: escapeURL :: string -> string

Escape the string so it can be safely placed inside a URL query.
Example

lib.strings.escapeURL usage example

escapeURL "foo/bar baz"
=> "foo%2Fbar%20baz"

Located at lib/strings.nix:415 in <nixpkgs>.
lib.strings.escapeShellArg

Type: escapeShellArg :: string -> string

Quote string to be used safely within the Bourne shell.

arg

    Function argument

Example

lib.strings.escapeShellArg usage example

escapeShellArg "esc'ape\nme"
=> "'esc'\\''ape\nme'"

Located at lib/strings.nix:429 in <nixpkgs>.
lib.strings.escapeShellArgs

Type: escapeShellArgs :: [string] -> string

Quote all arguments to be safely passed to the Bourne shell.
Example

lib.strings.escapeShellArgs usage example

escapeShellArgs ["one" "two three" "four'five"]
=> "'one' 'two three' 'four'\\''five'"

Located at lib/strings.nix:439 in <nixpkgs>.
lib.strings.isValidPosixName

Type: string -> bool

Test whether the given name is a valid POSIX shell variable name.

name

    Function argument

Example

lib.strings.isValidPosixName usage example

isValidPosixName "foo_bar000"
=> true
isValidPosixName "0-bad.jpg"
=> false

Located at lib/strings.nix:451 in <nixpkgs>.
lib.strings.toShellVar

Type: string -> (string | listOf string | attrsOf string) -> string

Translate a Nix value into a shell variable declaration, with proper escaping.

The value can be a string (mapped to a regular variable), a list of strings (mapped to a Bash-style array) or an attribute set of strings (mapped to a Bash-style associative array). Note that "string" includes string-coercible values like paths or derivations.

Strings are translated into POSIX sh-compatible code; lists and attribute sets assume a shell that understands Bash syntax (e.g. Bash or ZSH).

name

    Function argument

value

    Function argument

Example

lib.strings.toShellVar usage example

''
  ${toShellVar "foo" "some string"}
  [[ "$foo" == "some string" ]]
''

Located at lib/strings.nix:471 in <nixpkgs>.
lib.strings.toShellVars

Type: attrsOf (string | listOf string | attrsOf string) -> string

Translate an attribute set into corresponding shell variable declarations using toShellVar.

vars

    Function argument

Example

lib.strings.toShellVars usage example

let
  foo = "value";
  bar = foo;
in ''
  ${toShellVars { inherit foo bar; }}
  [[ "$foo" == "$bar" ]]
''

Located at lib/strings.nix:499 in <nixpkgs>.
lib.strings.escapeNixString

Type: string -> string

Turn a string into a Nix expression representing that string

s

    Function argument

Example

lib.strings.escapeNixString usage example

escapeNixString "hello\${}\n"
=> "\"hello\\\${}\\n\""

Located at lib/strings.nix:509 in <nixpkgs>.
lib.strings.escapeRegex

Type: string -> string

Turn a string into an exact regular expression
Example

lib.strings.escapeRegex usage example

escapeRegex "[^a-z]*"
=> "\\[\\^a-z]\\*"

Located at lib/strings.nix:519 in <nixpkgs>.
lib.strings.escapeNixIdentifier

Type: string -> string

Quotes a string if it can't be used as an identifier directly.

s

    Function argument

Example

lib.strings.escapeNixIdentifier usage example

escapeNixIdentifier "hello"
=> "hello"
escapeNixIdentifier "0abc"
=> "\"0abc\""

Located at lib/strings.nix:531 in <nixpkgs>.
lib.strings.escapeXML

Type: string -> string

Escapes a string such that it is safe to include verbatim in an XML document.
Example

lib.strings.escapeXML usage example

escapeXML ''"test" 'test' < & >''
=> "&quot;test&quot; &apos;test&apos; &lt; &amp; &gt;"

Located at lib/strings.nix:545 in <nixpkgs>.
lib.strings.toLower

Type: toLower :: string -> string

Converts an ASCII string to lower-case.
Example

lib.strings.toLower usage example

toLower "HOME"
=> "home"

Located at lib/strings.nix:564 in <nixpkgs>.
lib.strings.toUpper

Type: toUpper :: string -> string

Converts an ASCII string to upper-case.
Example

lib.strings.toUpper usage example

toUpper "home"
=> "HOME"

Located at lib/strings.nix:574 in <nixpkgs>.
lib.strings.addContextFrom

Appends string context from another string. This is an implementation detail of Nix and should be used carefully.

Strings in Nix carry an invisible context which is a list of strings representing store paths. If the string is later used in a derivation attribute, the derivation will properly populate the inputDrvs and inputSrcs.

a

    Function argument

b

    Function argument

Example

lib.strings.addContextFrom usage example

pkgs = import <nixpkgs> { };
addContextFrom pkgs.coreutils "bar"
=> "bar"

Located at lib/strings.nix:589 in <nixpkgs>.
lib.strings.splitString

Cut a string with a separator and produces a list of strings which were separated by this separator.

sep

    Function argument

s

    Function argument

Example

lib.strings.splitString usage example

splitString "." "foo.bar.baz"
=> [ "foo" "bar" "baz" ]
splitString "/" "/usr/local/bin"
=> [ "" "usr" "local" "bin" ]

Located at lib/strings.nix:600 in <nixpkgs>.
lib.strings.removePrefix

Type: string -> string -> string

Return a string without the specified prefix, if the prefix matches.

prefix

    Prefix to remove if it matches

str

    Input string

Example

lib.strings.removePrefix usage example

removePrefix "foo." "foo.bar.baz"
=> "bar.baz"
removePrefix "xxx" "foo.bar.baz"
=> "foo.bar.baz"

Located at lib/strings.nix:616 in <nixpkgs>.
lib.strings.removeSuffix

Type: string -> string -> string

Return a string without the specified suffix, if the suffix matches.

suffix

    Suffix to remove if it matches

str

    Input string

Example

lib.strings.removeSuffix usage example

removeSuffix "front" "homefront"
=> "home"
removeSuffix "xxx" "homefront"
=> "homefront"

Located at lib/strings.nix:649 in <nixpkgs>.
lib.strings.versionOlder

Return true if string v1 denotes a version older than v2.

v1

    Function argument

v2

    Function argument

Example

lib.strings.versionOlder usage example

versionOlder "1.1" "1.2"
=> true
versionOlder "1.1" "1.1"
=> false

Located at lib/strings.nix:680 in <nixpkgs>.
lib.strings.versionAtLeast

Return true if string v1 denotes a version equal to or newer than v2.

v1

    Function argument

v2

    Function argument

Example

lib.strings.versionAtLeast usage example

versionAtLeast "1.1" "1.0"
=> true
versionAtLeast "1.1" "1.1"
=> true
versionAtLeast "1.1" "1.2"
=> false

Located at lib/strings.nix:692 in <nixpkgs>.
lib.strings.getName

This function takes an argument that's either a derivation or a derivation's "name" attribute and extracts the name part from that argument.

x

    Function argument

Example

lib.strings.getName usage example

getName "youtube-dl-2016.01.01"
=> "youtube-dl"
getName pkgs.youtube-dl
=> "youtube-dl"

Located at lib/strings.nix:704 in <nixpkgs>.
lib.strings.getVersion

This function takes an argument that's either a derivation or a derivation's "name" attribute and extracts the version part from that argument.

x

    Function argument

Example

lib.strings.getVersion usage example

getVersion "youtube-dl-2016.01.01"
=> "2016.01.01"
getVersion pkgs.youtube-dl
=> "2016.01.01"

Located at lib/strings.nix:721 in <nixpkgs>.
lib.strings.nameFromURL

Extract name with version from URL. Ask for separator which is supposed to start extension.

url

    Function argument

sep

    Function argument

Example

lib.strings.nameFromURL usage example

nameFromURL "https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2" "-"
=> "nix"
nameFromURL "https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2" "_"
=> "nix-1.7-x86"

Located at lib/strings.nix:737 in <nixpkgs>.
lib.strings.mesonOption

Type:

mesonOption :: string -> string -> string

@param feature The feature to be set
@param value The desired value

Create a -D= string that can be passed to typical Meson invocations.

feature

    Function argument

value

    Function argument

Example

lib.strings.mesonOption usage example

mesonOption "engine" "opengl"
=> "-Dengine=opengl"

Located at lib/strings.nix:756 in <nixpkgs>.
lib.strings.mesonBool

Type:

mesonBool :: string -> bool -> string

@param condition The condition to be made true or false
@param flag The controlling flag of the condition

Create a -D={true,false} string that can be passed to typical Meson invocations.

condition

    Function argument

flag

    Function argument

Example

lib.strings.mesonBool usage example

mesonBool "hardened" true
=> "-Dhardened=true"
mesonBool "static" false
=> "-Dstatic=false"

Located at lib/strings.nix:775 in <nixpkgs>.
lib.strings.mesonEnable

Type:

mesonEnable :: string -> bool -> string

@param feature The feature to be enabled or disabled
@param flag The controlling flag

Create a -D={enabled,disabled} string that can be passed to typical Meson invocations.

feature

    Function argument

flag

    Function argument

Example

lib.strings.mesonEnable usage example

mesonEnable "docs" true
=> "-Ddocs=enabled"
mesonEnable "savage" false
=> "-Dsavage=disabled"

Located at lib/strings.nix:794 in <nixpkgs>.
lib.strings.enableFeature

Create an --{enable,disable}- string that can be passed to standard GNU Autoconf scripts.

enable

    Function argument

feat

    Function argument

Example

lib.strings.enableFeature usage example

enableFeature true "shared"
=> "--enable-shared"
enableFeature false "shared"
=> "--disable-shared"

Located at lib/strings.nix:808 in <nixpkgs>.
lib.strings.enableFeatureAs

Create an --{enable-=,disable-} string that can be passed to standard GNU Autoconf scripts.

enable

    Function argument

feat

    Function argument

value

    Function argument

Example

lib.strings.enableFeatureAs usage example

enableFeatureAs true "shared" "foo"
=> "--enable-shared=foo"
enableFeatureAs false "shared" (throw "ignored")
=> "--disable-shared"

Located at lib/strings.nix:821 in <nixpkgs>.
lib.strings.withFeature

Create an --{with,without}- string that can be passed to standard GNU Autoconf scripts.

with_

    Function argument

feat

    Function argument

Example

lib.strings.withFeature usage example

withFeature true "shared"
=> "--with-shared"
withFeature false "shared"
=> "--without-shared"

Located at lib/strings.nix:832 in <nixpkgs>.
lib.strings.withFeatureAs

Create an --{with-=,without-} string that can be passed to standard GNU Autoconf scripts.

with_

    Function argument

feat

    Function argument

value

    Function argument

Example

lib.strings.withFeatureAs usage example

withFeatureAs true "shared" "foo"
=> "--with-shared=foo"
withFeatureAs false "shared" (throw "ignored")
=> "--without-shared"

Located at lib/strings.nix:845 in <nixpkgs>.
lib.strings.fixedWidthString

Type: fixedWidthString :: int -> string -> string -> string

Create a fixed width string with additional prefix to match required width.

This function will fail if the input string is longer than the requested length.

width

    Function argument

filler

    Function argument

str

    Function argument

Example

lib.strings.fixedWidthString usage example

fixedWidthString 5 "0" (toString 15)
=> "00015"

Located at lib/strings.nix:859 in <nixpkgs>.
lib.strings.fixedWidthNumber

Format a number adding leading zeroes up to fixed width.

width

    Function argument

n

    Function argument

Example

lib.strings.fixedWidthNumber usage example

fixedWidthNumber 5 15
=> "00015"

Located at lib/strings.nix:876 in <nixpkgs>.
lib.strings.floatToString

Convert a float to a string, but emit a warning when precision is lost during the conversion

float

    Function argument

Example

lib.strings.floatToString usage example

floatToString 0.000001
=> "0.000001"
floatToString 0.0000001
=> trace: warning: Imprecise conversion from float to string 0.000000
   "0.000000"

Located at lib/strings.nix:888 in <nixpkgs>.
lib.strings.isCoercibleToString

Soft-deprecated function. While the original implementation is available as isConvertibleWithToString, consider using isStringLike instead, if suitable.

Located at lib/strings.nix:896 in <nixpkgs>.
lib.strings.isConvertibleWithToString

Check whether a list or other value can be passed to toString.

Many types of value are coercible to string this way, including int, float, null, bool, list of similarly coercible values.

x

    Function argument

Located at lib/strings.nix:905 in <nixpkgs>.
lib.strings.isStringLike

Check whether a value can be coerced to a string. The value must be a string, path, or attribute set.

String-like values can be used without explicit conversion in string interpolations and in most functions that expect a string.

x

    Function argument

Located at lib/strings.nix:916 in <nixpkgs>.
lib.strings.isStorePath

Check whether a value is a store path.

x

    Function argument

Example

lib.strings.isStorePath usage example

isStorePath "/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11/bin/python"
=> false
isStorePath "/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11"
=> true
isStorePath pkgs.python
=> true
isStorePath [] || isStorePath 42 || isStorePath {} || …
=> false

Located at lib/strings.nix:934 in <nixpkgs>.
lib.strings.toInt

Type: string -> int

Parse a string as an int. Does not support parsing of integers with preceding zero due to ambiguity between zero-padded and octal numbers. See toIntBase10.

str

    Function argument

Example

lib.strings.toInt usage example

toInt "1337"
=> 1337

toInt "-4"
=> -4

toInt " 123 "
=> 123

toInt "00024"
=> error: Ambiguity in interpretation of 00024 between octal and zero padded integer.

toInt "3.14"
=> error: floating point JSON numbers are not supported

Located at lib/strings.nix:964 in <nixpkgs>.
lib.strings.toIntBase10

Type: string -> int

Parse a string as a base 10 int. This supports parsing of zero-padded integers.

str

    Function argument

Example

lib.strings.toIntBase10 usage example

toIntBase10 "1337"
=> 1337

toIntBase10 "-4"
=> -4

toIntBase10 " 123 "
=> 123

toIntBase10 "00024"
=> 24

toIntBase10 "3.14"
=> error: floating point JSON numbers are not supported

Located at lib/strings.nix:1015 in <nixpkgs>.
lib.strings.readPathsFromFile

Read a list of paths from file, relative to the rootPath. Lines beginning with # are treated as comments and ignored. Whitespace is significant.

NOTE: This function is not performant and should be avoided.
Example

lib.strings.readPathsFromFile usage example

readPathsFromFile /prefix
  ./pkgs/development/libraries/qt-5/5.4/qtbase/series
=> [ "/prefix/dlopen-resolv.patch" "/prefix/tzdir.patch"
     "/prefix/dlopen-libXcursor.patch" "/prefix/dlopen-openssl.patch"
     "/prefix/dlopen-dbus.patch" "/prefix/xdg-config-dirs.patch"
     "/prefix/nix-profiles-library-paths.patch"
     "/prefix/compose-search-path.patch" ]

Located at lib/strings.nix:1058 in <nixpkgs>.
lib.strings.fileContents

Type: fileContents :: path -> string

Read the contents of a file removing the trailing \n

file

    Function argument

Example

lib.strings.fileContents usage example

$ echo "1.0" > ./version

fileContents ./version
=> "1.0"

Located at lib/strings.nix:1078 in <nixpkgs>.
lib.strings.sanitizeDerivationName

Type: sanitizeDerivationName :: String -> String

Creates a valid derivation name from a potentially invalid one.
Example

lib.strings.sanitizeDerivationName usage example

sanitizeDerivationName "../hello.bar # foo"
=> "-hello.bar-foo"
sanitizeDerivationName ""
=> "unknown"
sanitizeDerivationName pkgs.hello
=> "-nix-store-2g75chlbpxlrqn15zlby2dfh8hr9qwbk-hello-2.10"

Located at lib/strings.nix:1093 in <nixpkgs>.
lib.strings.levenshtein

Type: levenshtein :: string -> string -> int

Computes the Levenshtein distance between two strings. Complexity O(n*m) where n and m are the lengths of the strings. Algorithm adjusted from https://stackoverflow.com/a/9750974/6605742

a

    Function argument

b

    Function argument

Example

lib.strings.levenshtein usage example

levenshtein "foo" "foo"
=> 0
levenshtein "book" "hook"
=> 1
levenshtein "hello" "Heyo"
=> 3

Located at lib/strings.nix:1132 in <nixpkgs>.
lib.strings.commonPrefixLength

Returns the length of the prefix common to both strings.

a

    Function argument

b

    Function argument

Located at lib/strings.nix:1153 in <nixpkgs>.
lib.strings.commonSuffixLength

Returns the length of the suffix common to both strings.

a

    Function argument

b

    Function argument

Located at lib/strings.nix:1161 in <nixpkgs>.
lib.strings.levenshteinAtMost

Type: levenshteinAtMost :: int -> string -> string -> bool

Returns whether the levenshtein distance between two strings is at most some value Complexity is O(min(n,m)) for k <= 2 and O(n*m) otherwise
Example

lib.strings.levenshteinAtMost usage example

levenshteinAtMost 0 "foo" "foo"
=> true
levenshteinAtMost 1 "foo" "boa"
=> false
levenshteinAtMost 2 "foo" "boa"
=> true
levenshteinAtMost 2 "This is a sentence" "this is a sentense."
=> false
levenshteinAtMost 3 "This is a sentence" "this is a sentense."
=> true

Located at lib/strings.nix:1185 in <nixpkgs>.




lib.fileset: file set functions
lib.fileset.toSource

Type:

toSource :: {
  root :: Path,
  fileset :: FileSet,
} -> SourceLike

Add the local files contained in fileset to the store as a single store path rooted at root.

The result is the store path as a string-like value, making it usable e.g. as the src of a derivation, or in string interpolation:

stdenv.mkDerivation {
  src = lib.fileset.toSource { ... };
  # ...
}

The name of the store path is always source.

structured function argument

: root

    (required) The local directory path that will correspond to the root of the resulting store path. Paths in strings, including Nix store paths, cannot be passed as root. root has to be a directory.

Note

Changing root only affects the directory structure of the resulting store path, it does not change which files are added to the store. The only way to change which files get added to the store is by changing the fileset attribute.

fileset

    (required) The file set whose files to import into the store. Currently the only way to construct file sets is using implicit coercion from paths. If a directory does not recursively contain any file, it is omitted from the store path contents.

Example

lib.fileset.toSource usage example

# Import the current directory into the store but only include files under ./src
toSource { root = ./.; fileset = ./src; }
=> "/nix/store/...-source"

# The file set coerced from path ./bar could contain files outside the root ./foo, which is not allowed
toSource { root = ./foo; fileset = ./bar; }
=> <error>

# The root has to be a local filesystem path
toSource { root = "/nix/store/...-source"; fileset = ./.; }
=> <error>

Located at lib/fileset/default.nix:66 in <nixpkgs>.




lib.filesystem: filesystem functions
lib.filesystem.pathType

Type: pathType :: Path -> String

The type of a path. The path needs to exist and be accessible. The result is either "directory" for a directory, "regular" for a regular file, "symlink" for a symlink, or "unknown" for anything else.
Example

lib.filesystem.pathType usage example

pathType /.
=> "directory"

pathType /some/file.nix
=> "regular"

Located at lib/filesystem.nix:33 in <nixpkgs>.
lib.filesystem.pathIsDirectory

Type: pathIsDirectory :: Path -> Bool

Whether a path exists and is a directory.

path

    Function argument

Example

lib.filesystem.pathIsDirectory usage example

pathIsDirectory /.
=> true

pathIsDirectory /this/does/not/exist
=> false

pathIsDirectory /some/file.nix
=> false

Located at lib/filesystem.nix:65 in <nixpkgs>.
lib.filesystem.pathIsRegularFile

Type: pathIsRegularFile :: Path -> Bool

Whether a path exists and is a regular file, meaning not a symlink or any other special file type.

path

    Function argument

Example

lib.filesystem.pathIsRegularFile usage example

pathIsRegularFile /.
=> false

pathIsRegularFile /this/does/not/exist
=> false

pathIsRegularFile /some/file.nix
=> true

Located at lib/filesystem.nix:84 in <nixpkgs>.
lib.filesystem.haskellPathsInDir

Type: Path -> Map String Path

A map of all haskell packages defined in the given path, identified by having a cabal file with the same name as the directory itself.

root

    The directory within to search

Located at lib/filesystem.nix:94 in <nixpkgs>.
lib.filesystem.locateDominatingFile

Type: RegExp -> Path -> Nullable { path : Path; matches : [ MatchResults ]; }

Find the first directory containing a file matching 'pattern' upward from a given 'file'. Returns 'null' if no directories contain a file matching 'pattern'.

pattern

    The pattern to search for

file

    The file to start searching upward from

Located at lib/filesystem.nix:117 in <nixpkgs>.
lib.filesystem.listFilesRecursive

Type: Path -> [ Path ]

Given a directory, return a flattened list of all files within it recursively.

dir

    The path to recursively list

Located at lib/filesystem.nix:145 in <nixpkgs>.




lib.path: path functions
lib.path.append

Type: append :: Path -> String -> Path

Append a subpath string to a path.

Like path + ("/" + string) but safer, because it errors instead of returning potentially surprising results. More specifically, it checks that the first argument is a path value type, and that the second argument is a valid subpath string.

Laws:

    Not influenced by subpath normalisation:

    append p s == append p (subpath.normalise s)

path

    The absolute path to append to

subpath

    The subpath string to append

Example

lib.path.append usage example

append /foo "bar/baz"
=> /foo/bar/baz

# subpaths don't need to be normalised
append /foo "./bar//baz/./"
=> /foo/bar/baz

# can append to root directory
append /. "foo/bar"
=> /foo/bar

# first argument needs to be a path value type
append "/foo" "bar"
=> <error>

# second argument needs to be a valid subpath string
append /foo /bar
=> <error>
append /foo ""
=> <error>
append /foo "/bar"
=> <error>
append /foo "../bar"
=> <error>

Located at lib/path/default.nix:166 in <nixpkgs>.
lib.path.hasPrefix

Type: hasPrefix :: Path -> Path -> Bool

Whether the first path is a component-wise prefix of the second path.

Laws:

    hasPrefix p q is only true if q == append p s for some subpath s.

    hasPrefix is a non-strict partial order over the set of all path values.

path1

    Function argument

Example

lib.path.hasPrefix usage example

hasPrefix /foo /foo/bar
=> true
hasPrefix /foo /foo
=> true
hasPrefix /foo/bar /foo
=> false
hasPrefix /. /foo
=> true

Located at lib/path/default.nix:200 in <nixpkgs>.
lib.path.removePrefix

Type: removePrefix :: Path -> Path -> String

Remove the first path as a component-wise prefix from the second path. The result is a normalised subpath string.

Laws:

    Inverts append for normalised subpath string:

    removePrefix p (append p s) == subpath.normalise s

path1

    Function argument

Example

lib.path.removePrefix usage example

removePrefix /foo /foo/bar/baz
=> "./bar/baz"
removePrefix /foo /foo
=> "./."
removePrefix /foo/bar /foo
=> <error>
removePrefix /. /foo
=> "./foo"

Located at lib/path/default.nix:245 in <nixpkgs>.
lib.path.splitRoot

Type: splitRoot :: Path -> { root :: Path, subpath :: String }

Split the filesystem root from a path. The result is an attribute set with these attributes:

    root: The filesystem root of the path, meaning that this directory has no parent directory.
    subpath: The normalised subpath string that when appended to root returns the original path.

Laws:

    Appending the root and subpath gives the original path:

    p ==
      append
        (splitRoot p).root
        (splitRoot p).subpath

    Trying to get the parent directory of root using readDir returns root itself:

    dirOf (splitRoot p).root == (splitRoot p).root

path

    The path to split the root off of

Example

lib.path.splitRoot usage example

splitRoot /foo/bar
=> { root = /.; subpath = "./foo/bar"; }

splitRoot /.
=> { root = /.; subpath = "./."; }

# Nix neutralises `..` path components for all path values automatically
splitRoot /foo/../bar
=> { root = /.; subpath = "./bar"; }

splitRoot "/foo/bar"
=> <error>

Located at lib/path/default.nix:310 in <nixpkgs>.
lib.path.subpath.isValid

Type: subpath.isValid :: String -> Bool

Whether a value is a valid subpath string.

A subpath string points to a specific file or directory within an absolute base directory. It is a stricter form of a relative path that excludes .. components, since those could escape the base directory.

    The value is a string.

    The string is not empty.

    The string doesn't start with a /.

    The string doesn't contain any .. path components.

value

    The value to check

Example

lib.path.subpath.isValid usage example

# Not a string
subpath.isValid null
=> false

# Empty string
subpath.isValid ""
=> false

# Absolute path
subpath.isValid "/foo"
=> false

# Contains a `..` path component
subpath.isValid "../foo"
=> false

# Valid subpath
subpath.isValid "foo/bar"
=> true

# Doesn't need to be normalised
subpath.isValid "./foo//bar/"
=> true

Located at lib/path/default.nix:365 in <nixpkgs>.
lib.path.subpath.join

Type: subpath.join :: [ String ] -> String

Join subpath strings together using /, returning a normalised subpath string.

Like concatStringsSep "/" but safer, specifically:

    All elements must be valid subpath strings.

    The result gets normalised.

    The edge case of an empty list gets properly handled by returning the neutral subpath "./.".

Laws:

    Associativity:

    subpath.join [ x (subpath.join [ y z ]) ] == subpath.join [ (subpath.join [ x y ]) z ]

    Identity - "./." is the neutral element for normalised paths:

    subpath.join [ ] == "./."
    subpath.join [ (subpath.normalise p) "./." ] == subpath.normalise p
    subpath.join [ "./." (subpath.normalise p) ] == subpath.normalise p

    Normalisation - the result is normalised:

    subpath.join ps == subpath.normalise (subpath.join ps)

    For non-empty lists, the implementation is equivalent to normalising the result of concatStringsSep "/". Note that the above laws can be derived from this one:

    ps != [] -> subpath.join ps == subpath.normalise (concatStringsSep "/" ps)

subpaths

    The list of subpaths to join together

Example

lib.path.subpath.join usage example

subpath.join [ "foo" "bar/baz" ]
=> "./foo/bar/baz"

# normalise the result
subpath.join [ "./foo" "." "bar//./baz/" ]
=> "./foo/bar/baz"

# passing an empty list results in the current directory
subpath.join [ ]
=> "./."

# elements must be valid subpath strings
subpath.join [ /foo ]
=> <error>
subpath.join [ "" ]
=> <error>
subpath.join [ "/foo" ]
=> <error>
subpath.join [ "../foo" ]
=> <error>

Located at lib/path/default.nix:428 in <nixpkgs>.
lib.path.subpath.components

Type: subpath.components :: String -> [ String ]

Split a subpath into its path component strings. Throw an error if the subpath isn't valid. Note that the returned path components are also valid subpath strings, though they are intentionally not normalised.

Laws:

    Splitting a subpath into components and joining the components gives the same subpath but normalised:

    subpath.join (subpath.components s) == subpath.normalise s

subpath

    The subpath string to split into components

Example

lib.path.subpath.components usage example

subpath.components "."
=> [ ]

subpath.components "./foo//bar/./baz/"
=> [ "foo" "bar" "baz" ]

subpath.components "/foo"
=> <error>

Located at lib/path/default.nix:470 in <nixpkgs>.
lib.path.subpath.normalise

Type: subpath.normalise :: String -> String

Normalise a subpath. Throw an error if the subpath isn't valid.

    Limit repeating / to a single one.

    Remove redundant . components.

    Remove trailing / and /..

    Add leading ./.

Laws:

    Idempotency - normalising multiple times gives the same result:

    subpath.normalise (subpath.normalise p) == subpath.normalise p

    Uniqueness - there's only a single normalisation for the paths that lead to the same file system node:

    subpath.normalise p != subpath.normalise q -> $(realpath ${p}) != $(realpath ${q})

    Don't change the result when appended to a Nix path value:

    append base p == append base (subpath.normalise p)

    Don't change the path according to realpath:

    $(realpath ${p}) == $(realpath ${subpath.normalise p})

    Only error on invalid subpaths:

    builtins.tryEval (subpath.normalise p)).success == subpath.isValid p

subpath

    The subpath string to normalise

Example

lib.path.subpath.normalise usage example

# limit repeating `/` to a single one
subpath.normalise "foo//bar"
=> "./foo/bar"

# remove redundant `.` components
subpath.normalise "foo/./bar"
=> "./foo/bar"

# add leading `./`
subpath.normalise "foo/bar"
=> "./foo/bar"

# remove trailing `/`
subpath.normalise "foo/bar/"
=> "./foo/bar"

# remove trailing `/.`
subpath.normalise "foo/bar/."
=> "./foo/bar"

# Return the current directory as `./.`
subpath.normalise "."
=> "./."

# error on `..` path components
subpath.normalise "foo/../bar"
=> <error>

# error on empty string
subpath.normalise ""
=> <error>

# error on absolute path
subpath.normalise "/foo"
=> <error>

Located at lib/path/default.nix:551 in <nixpkgs>.


lib.attrsets: attribute set functions
lib.attrsets.attrByPath

Type: attrByPath :: [String] -> Any -> AttrSet -> Any

Return an attribute from nested attribute sets.

attrPath

    A list of strings representing the attribute path to return from set

default

    Default value if attrPath does not resolve to an existing value

set

    The nested attribute set to select values from

Example

lib.attrsets.attrByPath usage example

x = { a = { b = 3; }; }
# ["a" "b"] is equivalent to x.a.b
# 6 is a default value to return if the path does not exist in attrset
attrByPath ["a" "b"] 6 x
=> 3
attrByPath ["z" "z"] 6 x
=> 6

Located at lib/attrsets.nix:30 in <nixpkgs>.
lib.attrsets.hasAttrByPath

Type: hasAttrByPath :: [String] -> AttrSet -> Bool

Return if an attribute from nested attribute set exists.

attrPath

    A list of strings representing the attribute path to check from set

e

    The nested attribute set to check

Example

lib.attrsets.hasAttrByPath usage example

x = { a = { b = 3; }; }
hasAttrByPath ["a" "b"] x
=> true
hasAttrByPath ["z" "z"] x
=> false

Located at lib/attrsets.nix:56 in <nixpkgs>.
lib.attrsets.setAttrByPath

Type: setAttrByPath :: [String] -> Any -> AttrSet

Create a new attribute set with value set at the nested attribute location specified in attrPath.

attrPath

    A list of strings representing the attribute path to set

value

    The value to set at the location described by attrPath

Example

lib.attrsets.setAttrByPath usage example

setAttrByPath ["a" "b"] 3
=> { a = { b = 3; }; }

Located at lib/attrsets.nix:78 in <nixpkgs>.
lib.attrsets.getAttrFromPath

Type: getAttrFromPath :: [String] -> AttrSet -> Any

Like attrByPath, but without a default value. If it doesn't find the path it will throw an error.

attrPath

    A list of strings representing the attribute path to get from set

set

    The nested attribute set to find the value in.

Example

lib.attrsets.getAttrFromPath usage example

x = { a = { b = 3; }; }
getAttrFromPath ["a" "b"] x
=> 3
getAttrFromPath ["z" "z"] x
=> error: cannot find attribute `z.z'

Located at lib/attrsets.nix:104 in <nixpkgs>.
lib.attrsets.concatMapAttrs

Type: concatMapAttrs :: (String -> a -> AttrSet) -> AttrSet -> AttrSet

Map each attribute in the given set and merge them into a new attribute set.

f

    Function argument

v

    Function argument

Example

lib.attrsets.concatMapAttrs usage example

concatMapAttrs
  (name: value: {
    ${name} = value;
    ${name + value} = value;
  })
  { x = "a"; y = "b"; }
=> { x = "a"; xa = "a"; y = "b"; yb = "b"; }

Located at lib/attrsets.nix:126 in <nixpkgs>.
lib.attrsets.updateManyAttrsByPath

Type: updateManyAttrsByPath :: [{ path :: [String]; update :: (Any -> Any); }] -> AttrSet -> AttrSet

Update or set specific paths of an attribute set.

Takes a list of updates to apply and an attribute set to apply them to, and returns the attribute set with the updates applied. Updates are represented as { path = ...; update = ...; } values, where path is a list of strings representing the attribute path that should be updated, and update is a function that takes the old value at that attribute path as an argument and returns the new value it should be.

Properties:

    Updates to deeper attribute paths are applied before updates to more shallow attribute paths

    Multiple updates to the same attribute path are applied in the order they appear in the update list

    If any but the last path element leads into a value that is not an attribute set, an error is thrown

    If there is an update for an attribute path that doesn't exist, accessing the argument in the update function causes an error, but intermediate attribute sets are implicitly created as needed

Example

lib.attrsets.updateManyAttrsByPath usage example

updateManyAttrsByPath [
  {
    path = [ "a" "b" ];
    update = old: { d = old.c; };
  }
  {
    path = [ "a" "b" "c" ];
    update = old: old + 1;
  }
  {
    path = [ "x" "y" ];
    update = old: "xy";
  }
] { a.b.c = 0; }
=> { a = { b = { d = 1; }; }; x = { y = "xy"; }; }

Located at lib/attrsets.nix:177 in <nixpkgs>.
lib.attrsets.attrVals

Type: attrVals :: [String] -> AttrSet -> [Any]

Return the specified attributes from a set.

nameList

    The list of attributes to fetch from set. Each attribute name must exist on the attrbitue set

set

    The set to get attribute values from

Example

lib.attrsets.attrVals usage example

attrVals ["a" "b" "c"] as
=> [as.a as.b as.c]

Located at lib/attrsets.nix:245 in <nixpkgs>.
lib.attrsets.attrValues

Type: attrValues :: AttrSet -> [Any]

Return the values of all attributes in the given set, sorted by attribute name.
Example

lib.attrsets.attrValues usage example

attrValues {c = 3; a = 1; b = 2;}
=> [1 2 3]

Located at lib/attrsets.nix:262 in <nixpkgs>.
lib.attrsets.getAttrs

Type: getAttrs :: [String] -> AttrSet -> AttrSet

Given a set of attribute names, return the set of the corresponding attributes from the given set.

names

    A list of attribute names to get out of set

attrs

    The set to get the named attributes from

Example

lib.attrsets.getAttrs usage example

getAttrs [ "a" "b" ] { a = 1; b = 2; c = 3; }
=> { a = 1; b = 2; }

Located at lib/attrsets.nix:275 in <nixpkgs>.
lib.attrsets.catAttrs

Type: catAttrs :: String -> [AttrSet] -> [Any]

Collect each attribute named attr from a list of attribute sets. Sets that don't contain the named attribute are ignored.
Example

lib.attrsets.catAttrs usage example

catAttrs "a" [{a = 1;} {b = 0;} {a = 2;}]
=> [1 2]

Located at lib/attrsets.nix:291 in <nixpkgs>.
lib.attrsets.filterAttrs

Type: filterAttrs :: (String -> Any -> Bool) -> AttrSet -> AttrSet

Filter an attribute set by removing all attributes for which the given predicate return false.

pred

    Predicate taking an attribute name and an attribute value, which returns true to include the attribute, or false to exclude the attribute.

set

    The attribute set to filter

Example

lib.attrsets.filterAttrs usage example

filterAttrs (n: v: n == "foo") { foo = 1; bar = 2; }
=> { foo = 1; }

Located at lib/attrsets.nix:305 in <nixpkgs>.
lib.attrsets.filterAttrsRecursive

Type: filterAttrsRecursive :: (String -> Any -> Bool) -> AttrSet -> AttrSet

Filter an attribute set recursively by removing all attributes for which the given predicate return false.

pred

    Predicate taking an attribute name and an attribute value, which returns true to include the attribute, or false to exclude the attribute.

set

    The attribute set to filter

Example

lib.attrsets.filterAttrsRecursive usage example

filterAttrsRecursive (n: v: v != null) { foo = { bar = null; }; }
=> { foo = {}; }

Located at lib/attrsets.nix:323 in <nixpkgs>.
lib.attrsets.foldlAttrs

Type: foldlAttrs :: ( a -> String -> b -> a ) -> a -> { ... :: b } -> a

Like builtins.foldl' but for attribute sets. Iterates over every name-value pair in the given attribute set. The result of the callback function is often called acc for accumulator. It is passed between callbacks from left to right and the final acc is the return value of foldlAttrs.

Attention: There is a completely different function lib.foldAttrs which has nothing to do with this function, despite the similar name.

f

    Function argument

init

    Function argument

set

    Function argument

Example

lib.attrsets.foldlAttrs usage example

foldlAttrs
  (acc: name: value: {
    sum = acc.sum + value;
    names = acc.names ++ [name];
  })
  { sum = 0; names = []; }
  {
    foo = 1;
    bar = 10;
  }
->
  {
    sum = 11;
    names = ["bar" "foo"];
  }

foldlAttrs
  (throw "function not needed")
  123
  {};
->
  123

foldlAttrs
  (_: _: v: v)
  (throw "initial accumulator not needed")
  { z = 3; a = 2; };
->
  3

The accumulator doesn't have to be an attrset.
It can be as simple as a number or string.

foldlAttrs
  (acc: _: v: acc * 10 + v)
  1
  { z = 1; a = 2; };
->
  121

Located at lib/attrsets.nix:394 in <nixpkgs>.
lib.attrsets.foldAttrs

Type: foldAttrs :: (Any -> Any -> Any) -> Any -> [AttrSets] -> Any

Apply fold functions to values grouped by key.

op

    A function, given a value and a collector combines the two.

nul

    The starting value.

list_of_attrs

    A list of attribute sets to fold together by key.

Example

lib.attrsets.foldAttrs usage example

foldAttrs (item: acc: [item] ++ acc) [] [{ a = 2; } { a = 3; }]
=> { a = [ 2 3 ]; }

Located at lib/attrsets.nix:410 in <nixpkgs>.
lib.attrsets.collect

Type: collect :: (AttrSet -> Bool) -> AttrSet -> [x]

Recursively collect sets that verify a given predicate named pred from the set attrs. The recursion is stopped when the predicate is verified.

pred

    Given an attribute's value, determine if recursion should stop.

attrs

    The attribute set to recursively collect.

Example

lib.attrsets.collect usage example

collect isList { a = { b = ["b"]; }; c = [1]; }
=> [["b"] [1]]

collect (x: x ? outPath)
   { a = { outPath = "a/"; }; b = { outPath = "b/"; }; }
=> [{ outPath = "a/"; } { outPath = "b/"; }]

Located at lib/attrsets.nix:439 in <nixpkgs>.
lib.attrsets.cartesianProductOfSets

Type: cartesianProductOfSets :: AttrSet -> [AttrSet]

Return the cartesian product of attribute set value combinations.

attrsOfLists

    Attribute set with attributes that are lists of values

Example

lib.attrsets.cartesianProductOfSets usage example

cartesianProductOfSets { a = [ 1 2 ]; b = [ 10 20 ]; }
=> [
     { a = 1; b = 10; }
     { a = 1; b = 20; }
     { a = 2; b = 10; }
     { a = 2; b = 20; }
   ]

Located at lib/attrsets.nix:464 in <nixpkgs>.
lib.attrsets.nameValuePair

Type: nameValuePair :: String -> Any -> { name :: String; value :: Any; }

Utility function that creates a {name, value} pair as expected by builtins.listToAttrs.

name

    Attribute name

value

    Attribute value

Example

lib.attrsets.nameValuePair usage example

nameValuePair "some" 6
=> { name = "some"; value = 6; }

Located at lib/attrsets.nix:483 in <nixpkgs>.
lib.attrsets.mapAttrs

Type: mapAttrs :: (String -> Any -> Any) -> AttrSet -> AttrSet

Apply a function to each element in an attribute set, creating a new attribute set.
Example

lib.attrsets.mapAttrs usage example

mapAttrs (name: value: name + "-" + value)
   { x = "foo"; y = "bar"; }
=> { x = "x-foo"; y = "y-bar"; }

Located at lib/attrsets.nix:501 in <nixpkgs>.
lib.attrsets.mapAttrs'

Type: mapAttrs' :: (String -> Any -> { name :: String; value :: Any; }) -> AttrSet -> AttrSet

Like mapAttrs, but allows the name of each attribute to be changed in addition to the value. The applied function should return both the new name and value as a nameValuePair.

f

    A function, given an attribute's name and value, returns a new nameValuePair.

set

    Attribute set to map over.

Example

lib.attrsets.mapAttrs' usage example

mapAttrs' (name: value: nameValuePair ("foo_" + name) ("bar-" + value))
   { x = "a"; y = "b"; }
=> { foo_x = "bar-a"; foo_y = "bar-b"; }

Located at lib/attrsets.nix:518 in <nixpkgs>.
lib.attrsets.mapAttrsToList

Type: mapAttrsToList :: (String -> a -> b) -> AttrSet -> [b]

Call a function for each attribute in the given set and return the result in a list.

f

    A function, given an attribute's name and value, returns a new value.

attrs

    Attribute set to map over.

Example

lib.attrsets.mapAttrsToList usage example

mapAttrsToList (name: value: name + value)
   { x = "a"; y = "b"; }
=> [ "xa" "yb" ]

Located at lib/attrsets.nix:538 in <nixpkgs>.
lib.attrsets.mapAttrsRecursive

Type: mapAttrsRecursive :: ([String] -> a -> b) -> AttrSet -> AttrSet

Like mapAttrs, except that it recursively applies itself to the leaf attributes of a potentially-nested attribute set: the second argument of the function will never be an attrset. Also, the first argument of the argument function is a list of the attribute names that form the path to the leaf attribute.

For a function that gives you control over what counts as a leaf, see mapAttrsRecursiveCond.

f

    A function, given a list of attribute names and a value, returns a new value.

set

    Set to recursively map over.

Example

lib.attrsets.mapAttrsRecursive usage example

mapAttrsRecursive (path: value: concatStringsSep "-" (path ++ [value]))
  { n = { a = "A"; m = { b = "B"; c = "C"; }; }; d = "D"; }
=> { n = { a = "n-a-A"; m = { b = "n-m-b-B"; c = "n-m-c-C"; }; }; d = "d-D"; }

Located at lib/attrsets.nix:563 in <nixpkgs>.
lib.attrsets.mapAttrsRecursiveCond

Type: mapAttrsRecursiveCond :: (AttrSet -> Bool) -> ([String] -> a -> b) -> AttrSet -> AttrSet

Like mapAttrsRecursive, but it takes an additional predicate function that tells it whether to recurse into an attribute set. If it returns false, mapAttrsRecursiveCond does not recurse, but does apply the map function. If it returns true, it does recurse, and does not apply the map function.

cond

    A function, given the attribute set the recursion is currently at, determine if to recurse deeper into that attribute set.

f

    A function, given a list of attribute names and a value, returns a new value.

set

    Attribute set to recursively map over.

Example

lib.attrsets.mapAttrsRecursiveCond usage example

# To prevent recursing into derivations (which are attribute
# sets with the attribute "type" equal to "derivation"):
mapAttrsRecursiveCond
  (as: !(as ? "type" && as.type == "derivation"))
  (x: ... do something ...)
  attrs

Located at lib/attrsets.nix:588 in <nixpkgs>.
lib.attrsets.genAttrs

Type: genAttrs :: [ String ] -> (String -> Any) -> AttrSet

Generate an attribute set by mapping a function over a list of attribute names.

names

    Names of values in the resulting attribute set.

f

    A function, given the name of the attribute, returns the attribute's value.

Example

lib.attrsets.genAttrs usage example

genAttrs [ "foo" "bar" ] (name: "x_" + name)
=> { foo = "x_foo"; bar = "x_bar"; }

Located at lib/attrsets.nix:617 in <nixpkgs>.
lib.attrsets.isDerivation

Type: isDerivation :: Any -> Bool

Check whether the argument is a derivation. Any set with { type = "derivation"; } counts as a derivation.

value

    Value to check.

Example

lib.attrsets.isDerivation usage example

nixpkgs = import <nixpkgs> {}
isDerivation nixpkgs.ruby
=> true
isDerivation "foobar"
=> false

Located at lib/attrsets.nix:638 in <nixpkgs>.
lib.attrsets.toDerivation

Type: toDerivation :: Path -> Derivation

Converts a store path to a fake derivation.

path

    A store path to convert to a derivation.

Located at lib/attrsets.nix:647 in <nixpkgs>.
lib.attrsets.optionalAttrs

Type: optionalAttrs :: Bool -> AttrSet -> AttrSet

If cond is true, return the attribute set as, otherwise an empty attribute set.

cond

    Condition under which the as attribute set is returned.

as

    The attribute set to return if cond is true.

Example

lib.attrsets.optionalAttrs usage example

optionalAttrs (true) { my = "set"; }
=> { my = "set"; }
optionalAttrs (false) { my = "set"; }
=> { }

Located at lib/attrsets.nix:675 in <nixpkgs>.
lib.attrsets.zipAttrsWithNames

Type: zipAttrsWithNames :: [ String ] -> (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet

Merge sets of attributes and use the function f to merge attributes values.

names

    List of attribute names to zip.

f

    A function, accepts an attribute name, all the values, and returns a combined value.

sets

    List of values from the list of attribute sets.

Example

lib.attrsets.zipAttrsWithNames usage example

zipAttrsWithNames ["a"] (name: vs: vs) [{a = "x";} {a = "y"; b = "z";}]
=> { a = ["x" "y"]; }

Located at lib/attrsets.nix:693 in <nixpkgs>.
lib.attrsets.zipAttrsWith

Type: zipAttrsWith :: (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet

Merge sets of attributes and use the function f to merge attribute values. Like lib.attrsets.zipAttrsWithNames with all key names are passed for names.

Implementation note: Common names appear multiple times in the list of names, hopefully this does not affect the system because the maximal laziness avoid computing twice the same expression and listToAttrs does not care about duplicated attribute names.
Example

lib.attrsets.zipAttrsWith usage example

zipAttrsWith (name: values: values) [{a = "x";} {a = "y"; b = "z";}]
=> { a = ["x" "y"]; b = ["z"]; }

Located at lib/attrsets.nix:721 in <nixpkgs>.
lib.attrsets.zipAttrs

Type: zipAttrs :: [ AttrSet ] -> AttrSet

Merge sets of attributes and combine each attribute value in to a list.

Like lib.attrsets.zipAttrsWith with (name: values: values) as the function.

sets

    List of attribute sets to zip together.

Example

lib.attrsets.zipAttrs usage example

zipAttrs [{a = "x";} {a = "y"; b = "z";}]
=> { a = ["x" "y"]; b = ["z"]; }

Located at lib/attrsets.nix:736 in <nixpkgs>.
lib.attrsets.mergeAttrsList

Type: mergeAttrsList :: [ Attrs ] -> Attrs

Merge a list of attribute sets together using the // operator. In case of duplicate attributes, values from later list elements take precedence over earlier ones. The result is the same as foldl mergeAttrs { }, but the performance is better for large inputs. For n list elements, each with an attribute set containing m unique attributes, the complexity of this operation is O(nm log n).

list

    Function argument

Example

lib.attrsets.mergeAttrsList usage example

mergeAttrsList [ { a = 0; b = 1; } { c = 2; d = 3; } ]
=> { a = 0; b = 1; c = 2; d = 3; }
mergeAttrsList [ { a = 0; } { a = 1; } ]
=> { a = 1; }

Located at lib/attrsets.nix:756 in <nixpkgs>.
lib.attrsets.recursiveUpdateUntil

Type: recursiveUpdateUntil :: ( [ String ] -> AttrSet -> AttrSet -> Bool ) -> AttrSet -> AttrSet -> AttrSet

Does the same as the update operator '//' except that attributes are merged until the given predicate is verified. The predicate should accept 3 arguments which are the path to reach the attribute, a part of the first attribute set and a part of the second attribute set. When the predicate is satisfied, the value of the first attribute set is replaced by the value of the second attribute set.

pred

    Predicate, taking the path to the current attribute as a list of strings for attribute names, and the two values at that path from the original arguments.

lhs

    Left attribute set of the merge.

rhs

    Right attribute set of the merge.

Example

lib.attrsets.recursiveUpdateUntil usage example

recursiveUpdateUntil (path: l: r: path == ["foo"]) {
  # first attribute set
  foo.bar = 1;
  foo.baz = 2;
  bar = 3;
} {
  #second attribute set
  foo.bar = 1;
  foo.quz = 2;
  baz = 4;
}

=> {
  foo.bar = 1; # 'foo.*' from the second set
  foo.quz = 2; #
  bar = 3;     # 'bar' from the first set
  baz = 4;     # 'baz' from the second set
}

Located at lib/attrsets.nix:808 in <nixpkgs>.
lib.attrsets.recursiveUpdate

Type: recursiveUpdate :: AttrSet -> AttrSet -> AttrSet

A recursive variant of the update operator ‘//’. The recursion stops when one of the attribute values is not an attribute set, in which case the right hand side value takes precedence over the left hand side value.

lhs

    Left attribute set of the merge.

rhs

    Right attribute set of the merge.

Example

lib.attrsets.recursiveUpdate usage example

recursiveUpdate {
  boot.loader.grub.enable = true;
  boot.loader.grub.device = "/dev/hda";
} {
  boot.loader.grub.device = "";
}

returns: {
  boot.loader.grub.enable = true;
  boot.loader.grub.device = "";
}

Located at lib/attrsets.nix:848 in <nixpkgs>.
lib.attrsets.matchAttrs

Type: matchAttrs :: AttrSet -> AttrSet -> Bool

Returns true if the pattern is contained in the set. False otherwise.

pattern

    Attribute set structure to match

attrs

    Attribute set to find patterns in

Example

lib.attrsets.matchAttrs usage example

matchAttrs { cpu = {}; } { cpu = { bits = 64; }; }
=> true

Located at lib/attrsets.nix:865 in <nixpkgs>.
lib.attrsets.overrideExisting

Type: overrideExisting :: AttrSet -> AttrSet -> AttrSet

Override only the attributes that are already present in the old set useful for deep-overriding.

old

    Original attribute set

new

    Attribute set with attributes to override in old.

Example

lib.attrsets.overrideExisting usage example

overrideExisting {} { a = 1; }
=> {}
overrideExisting { b = 2; } { a = 1; }
=> { b = 2; }
overrideExisting { a = 3; b = 2; } { a = 1; }
=> { a = 1; b = 2; }

Located at lib/attrsets.nix:893 in <nixpkgs>.
lib.attrsets.showAttrPath

Type: showAttrPath :: [String] -> String

Turns a list of strings into a human-readable description of those strings represented as an attribute path. The result of this function is not intended to be machine-readable. Create a new attribute set with value set at the nested attribute location specified in attrPath.

path

    Attribute path to render to a string

Example

lib.attrsets.showAttrPath usage example

showAttrPath [ "foo" "10" "bar" ]
=> "foo.\"10\".bar"
showAttrPath []
=> "<root attribute path>"

Located at lib/attrsets.nix:915 in <nixpkgs>.
lib.attrsets.getOutput

Type: getOutput :: String -> Derivation -> String

Get a package output. If no output is found, fallback to .out and then to the default.

output

    Function argument

pkg

    Function argument

Example

lib.attrsets.getOutput usage example

getOutput "dev" pkgs.openssl
=> "/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev"

Located at lib/attrsets.nix:932 in <nixpkgs>.
lib.attrsets.getBin

Type: getBin :: Derivation -> String

Get a package's bin output. If the output does not exist, fallback to .out and then to the default.
Example

lib.attrsets.getBin usage example

getBin pkgs.openssl
=> "/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r"

Located at lib/attrsets.nix:947 in <nixpkgs>.
lib.attrsets.getLib

Type: getLib :: Derivation -> String

Get a package's lib output. If the output does not exist, fallback to .out and then to the default.
Example

lib.attrsets.getLib usage example

getLib pkgs.openssl
=> "/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-lib"

Located at lib/attrsets.nix:960 in <nixpkgs>.
lib.attrsets.getDev

Type: getDev :: Derivation -> String

Get a package's dev output. If the output does not exist, fallback to .out and then to the default.
Example

lib.attrsets.getDev usage example

getDev pkgs.openssl
=> "/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev"

Located at lib/attrsets.nix:973 in <nixpkgs>.
lib.attrsets.getMan

Type: getMan :: Derivation -> String

Get a package's man output. If the output does not exist, fallback to .out and then to the default.
Example

lib.attrsets.getMan usage example

getMan pkgs.openssl
=> "/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-man"

Located at lib/attrsets.nix:986 in <nixpkgs>.
lib.attrsets.chooseDevOutputs

Type: chooseDevOutputs :: [Derivation] -> [String]

Pick the outputs of packages to place in buildInputs

drvs

    List of packages to pick dev outputs from

Located at lib/attrsets.nix:993 in <nixpkgs>.
lib.attrsets.recurseIntoAttrs

Type: recurseIntoAttrs :: AttrSet -> AttrSet

Make various Nix tools consider the contents of the resulting attribute set when looking for what to build, find, etc.

This function only affects a single attribute set; it does not apply itself recursively for nested attribute sets.

attrs

    An attribute set to scan for derivations.

Example

lib.attrsets.recurseIntoAttrs usage example

{ pkgs ? import <nixpkgs> {} }:
{
  myTools = pkgs.lib.recurseIntoAttrs {
    inherit (pkgs) hello figlet;
  };
}

Located at lib/attrsets.nix:1016 in <nixpkgs>.
lib.attrsets.dontRecurseIntoAttrs

Type: dontRecurseIntoAttrs :: AttrSet -> AttrSet

Undo the effect of recurseIntoAttrs.

attrs

    An attribute set to not scan for derivations.

Located at lib/attrsets.nix:1026 in <nixpkgs>.
lib.attrsets.unionOfDisjoint

Type: unionOfDisjoint :: AttrSet -> AttrSet -> AttrSet

unionOfDisjoint x y is equal to x // y // z where the attrnames in z are the intersection of the attrnames in x and y, and all values assert with an error message. This operator is commutative, unlike (//).

x

    Function argument

y

    Function argument

Located at lib/attrsets.nix:1038 in <nixpkgs>.






Nix Reference Manual
Built-ins

This section lists the values and functions built into the Nix language evaluator. All built-ins are available through the global builtins constant.

Some built-ins are also exposed directly in the global scope:

    derivation
    import
    abort
    throw

derivation attrs

    derivation is described in its own section.
abort s

    Abort Nix expression evaluation and print the error message s.
add e1 e2

    Return the sum of the numbers e1 and e2.
addDrvOutputDependencies s

    Create a copy of the given string where a single constant string context element is turned into a derivation deep string context element.

    The store path that is the constant string context element should point to a valid derivation, and end in .drv.

    The original string context element must not be empty or have multiple elements, and it must not have any other type of element other than a constant or derivation deep element. The latter is supported so this function is idempotent.

    This is the opposite of builtins.unsafeDiscardOutputDependency.
all pred list

    Return true if the function pred returns true for all elements of list, and false otherwise.
any pred list

    Return true if the function pred returns true for at least one element of list, and false otherwise.
attrNames set

    Return the names of the attributes in the set set in an alphabetically sorted list. For instance, builtins.attrNames { y = 1; x = "foo"; } evaluates to [ "x" "y" ].
attrValues set

    Return the values of the attributes in the set set in the order corresponding to the sorted attribute names.
baseNameOf x

    Return the base name of either a path value x or a string x, depending on which type is passed, and according to the following rules.

    For a path value, the base name is considered to be the part of the path after the last directory separator, including any file extensions. This is the simple case, as path values don't have trailing slashes.

    When the argument is a string, a more involved logic applies. If the string ends with a /, only this one final slash is removed.

    After this, the base name is returned as previously described, assuming / as the directory separator. (Note that evaluation must be platform independent.)

    This is somewhat similar to the GNU basename command, but GNU basename will strip any number of trailing slashes.
bitAnd e1 e2

    Return the bitwise AND of the integers e1 and e2.
bitOr e1 e2

    Return the bitwise OR of the integers e1 and e2.
bitXor e1 e2

    Return the bitwise XOR of the integers e1 and e2.
break v

    In debug mode (enabled using --debugger), pause Nix expression evaluation and enter the REPL. Otherwise, return the argument v.
builtins (set)

    Contains all the built-in functions and values.

    Since built-in functions were added over time, testing for attributes in builtins can be used for graceful fallback on older Nix installations:

    # if hasContext is not available, we assume `s` has a context
    if builtins ? hasContext then builtins.hasContext s else true

catAttrs attr list

    Collect each attribute named attr from a list of attribute sets. Attrsets that don't contain the named attribute are ignored. For example,

    builtins.catAttrs "a" [{a = 1;} {b = 0;} {a = 2;}]

    evaluates to [1 2].
ceil double

    Converts an IEEE-754 double-precision floating-point number (double) to the next higher integer.

    If the datatype is neither an integer nor a "float", an evaluation error will be thrown.
compareVersions s1 s2

    Compare two strings representing versions and return -1 if version s1 is older than version s2, 0 if they are the same, and 1 if s1 is newer than s2. The version comparison algorithm is the same as the one used by nix-env -u.
concatLists lists

    Concatenate a list of lists into a single list.
concatMap f list

    This function is equivalent to builtins.concatLists (map f list) but is more efficient.
concatStringsSep separator list

    Concatenate a list of strings with a separator between each element, e.g. concatStringsSep "/" ["usr" "local" "bin"] == "usr/local/bin".
convertHash args

    Return the specified representation of a hash string, based on the attributes presented in args:

        hash

        The hash to be converted. The hash format is detected automatically.

        hashAlgo

        The algorithm used to create the hash. Must be one of
            "md5"
            "sha1"
            "sha256"
            "sha512"

        The attribute may be omitted when hash is an SRI hash or when the hash is prefixed with the hash algorithm name followed by a colon. That <hashAlgo>:<hashBody> syntax is supported for backwards compatibility with existing tooling.

        toHashFormat

        The format of the resulting hash. Must be one of
            "base16"
            "nix32"
            "base32" (deprecated alias for "nix32")
            "base64"
            "sri"

    The result hash is the toHashFormat representation of the hash hash.

        Example

        Convert a SHA256 hash in Base16 to SRI:

builtins.convertHash {
  hash = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  toHashFormat = "sri";
  hashAlgo = "sha256";
}

    "sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU="

    Example

    Convert a SHA256 hash in SRI to Base16:

builtins.convertHash {
  hash = "sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=";
  toHashFormat = "base16";
}

    "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"

    Example

    Convert a hash in the form <hashAlgo>:<hashBody> in Base16 to SRI:

builtins.convertHash {
  hash = "sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  toHashFormat = "sri";
}

        "sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU="

currentSystem (string)

    The value of the eval-system or else system configuration option.

    It can be used to set the system attribute for builtins.derivation such that the resulting derivation can be built on the same system that evaluates the Nix expression:

 builtins.derivation {
   # ...
   system = builtins.currentSystem;
}

It can be overridden in order to create derivations for different system than the current one:

     nix-instantiate --system "mips64-linux" --eval --expr 'builtins.currentSystem'
    "mips64-linux"

        Note

        Not available in pure evaluation mode.

currentTime (integer)

    Return the Unix time at first evaluation. Repeated references to that name will re-use the initially obtained value.

    Example:

 nix repl
Welcome to Nix 2.15.1 Type :? for help.

 builtins.currentTime
1683705525

     builtins.currentTime
    1683705525

    The store path of a derivation depending on currentTime will differ for each evaluation, unless both evaluate builtins.currentTime in the same second.

        Note

        Not available in pure evaluation mode.

deepSeq e1 e2

    This is like seq e1 e2, except that e1 is evaluated deeply: if it’s a list or set, its elements or attributes are also evaluated recursively.
dirOf s

    Return the directory part of the string s, that is, everything before the final slash in the string. This is similar to the GNU dirname command.
div e1 e2

    Return the quotient of the numbers e1 and e2.
elem x xs

    Return true if a value equal to x occurs in the list xs, and false otherwise.
elemAt xs n

    Return element n from the list xs. Elements are counted starting from 0. A fatal error occurs if the index is out of bounds.
false (Boolean)

    Primitive value.

    It can be returned by comparison operators and used in conditional expressions.

    The name false is not special, and can be shadowed:

    nix-repl> let false = 1; in false
    1

fetchClosure args

        Note

        This function is only available if the fetch-closure experimental feature is enabled.

        For example, include the following in nix.conf:

    extra-experimental-features = fetch-closure

Fetch a store path closure from a binary cache, and return the store path as a string with context.

This function can be invoked in three ways, that we will discuss in order of preference.

Fetch a content-addressed store path

Example:

builtins.fetchClosure {
  fromStore = "https://cache.nixos.org";
  fromPath = /nix/store/ldbhlwhh39wha58rm61bkiiwm6j7211j-git-2.33.1;
}

This is the simplest invocation, and it does not require the user of the expression to configure trusted-public-keys to ensure their authenticity.

If your store path is input addressed instead of content addressed, consider the other two invocations.

Fetch any store path and rewrite it to a fully content-addressed store path

Example:

builtins.fetchClosure {
  fromStore = "https://cache.nixos.org";
  fromPath = /nix/store/r2jd6ygnmirm2g803mksqqjm4y39yi6i-git-2.33.1;
  toPath = /nix/store/ldbhlwhh39wha58rm61bkiiwm6j7211j-git-2.33.1;
}

This example fetches /nix/store/r2jd... from the specified binary cache, and rewrites it into the content-addressed store path /nix/store/ldbh....

Like the previous example, no extra configuration or privileges are required.

To find out the correct value for toPath given a fromPath, use nix store make-content-addressed:

 nix store make-content-addressed --from https://cache.nixos.org /nix/store/r2jd6ygnmirm2g803mksqqjm4y39yi6i-git-2.33.1
rewrote '/nix/store/r2jd6ygnmirm2g803mksqqjm4y39yi6i-git-2.33.1' to '/nix/store/ldbhlwhh39wha58rm61bkiiwm6j7211j-git-2.33.1'

Alternatively, set toPath = "" and find the correct toPath in the error message.

Fetch an input-addressed store path as is

Example:

    builtins.fetchClosure {
      fromStore = "https://cache.nixos.org";
      fromPath = /nix/store/r2jd6ygnmirm2g803mksqqjm4y39yi6i-git-2.33.1;
      inputAddressed = true;
    }

    It is possible to fetch an input-addressed store path and return it as is. However, this is the least preferred way of invoking fetchClosure, because it requires that the input-addressed paths are trusted by the Nix configuration.

    builtins.storePath

    fetchClosure is similar to builtins.storePath in that it allows you to use a previously built store path in a Nix expression. However, fetchClosure is more reproducible because it specifies a binary cache from which the path can be fetched. Also, using content-addressed store paths does not require users to configure trusted-public-keys to ensure their authenticity.
fetchGit args

    Fetch a path from git. args can be a URL, in which case the HEAD of the repo at that URL is fetched. Otherwise, it can be an attribute with the following attributes (all except url optional):

        url

        The URL of the repo.

        name (default: source)

        The name of the directory the repo should be exported to in the store.

        rev (default: the tip of ref)

        The Git revision to fetch. This is typically a commit hash.

        ref (default: HEAD)

        The Git reference under which to look for the requested revision. This is often a branch or tag name.

        This option has no effect once shallow cloning is enabled.

        By default, the ref value is prefixed with refs/heads/. As of 2.3.0, Nix will not prefix refs/heads/ if ref starts with refs/.

        submodules (default: false)

        A Boolean parameter that specifies whether submodules should be checked out.

        exportIgnore (default: true)

        A Boolean parameter that specifies whether export-ignore from .gitattributes should be applied. This approximates part of the git archive behavior.

        Enabling this option is not recommended because it is unknown whether the Git developers commit to the reproducibility of export-ignore in newer Git versions.

        shallow (default: false)

        Make a shallow clone when fetching the Git tree. When this is enabled, the options ref and allRefs have no effect anymore.

        allRefs

        Whether to fetch all references (eg. branches and tags) of the repository. With this argument being true, it's possible to load a rev from any ref. (by default only revs from the specified ref are supported).

        This option has no effect once shallow cloning is enabled.

        verifyCommit (default: true if publicKey or publicKeys are provided, otherwise false)

        Whether to check rev for a signature matching publicKey or publicKeys. If verifyCommit is enabled, then fetchGit cannot use a local repository with uncommitted changes. Requires the verified-fetches experimental feature.

        publicKey

        The public key against which rev is verified if verifyCommit is enabled. Requires the verified-fetches experimental feature.

        keytype (default: "ssh-ed25519")

        The key type of publicKey. Possible values:
            "ssh-dsa"
            "ssh-ecdsa"
            "ssh-ecdsa-sk"
            "ssh-ed25519"
            "ssh-ed25519-sk"
            "ssh-rsa" Requires the verified-fetches experimental feature.

        publicKeys

        The public keys against which rev is verified if verifyCommit is enabled. Must be given as a list of attribute sets with the following form:

    {
      key = "<public key>";
      type = "<key type>"; # optional, default: "ssh-ed25519"
    }

    Requires the verified-fetches experimental feature.

Here are some examples of how to use fetchGit.

    To fetch a private repository over SSH:

builtins.fetchGit {
  url = "git@github.com:my-secret/repository.git";
  ref = "master";
  rev = "adab8b916a45068c044658c4158d81878f9ed1c3";
}

To fetch an arbitrary reference:

builtins.fetchGit {
  url = "https://github.com/NixOS/nix.git";
  ref = "refs/heads/0.5-release";
}

If the revision you're looking for is in the default branch of the git repository you don't strictly need to specify the branch name in the ref attribute.

However, if the revision you're looking for is in a future branch for the non-default branch you will need to specify the the ref attribute as well.

builtins.fetchGit {
  url = "https://github.com/nixos/nix.git";
  rev = "841fcbd04755c7a2865c51c1e2d3b045976b7452";
  ref = "1.11-maintenance";
}

    Note

    It is nice to always specify the branch which a revision belongs to. Without the branch being specified, the fetcher might fail if the default branch changes. Additionally, it can be confusing to try a commit from a non-default branch and see the fetch fail. If the branch is specified the fault is much more obvious.

If the revision you're looking for is in the default branch of the git repository you may omit the ref attribute.

builtins.fetchGit {
  url = "https://github.com/nixos/nix.git";
  rev = "841fcbd04755c7a2865c51c1e2d3b045976b7452";
}

To fetch a specific tag:

builtins.fetchGit {
  url = "https://github.com/nixos/nix.git";
  ref = "refs/tags/1.9";
}

To fetch the latest version of a remote branch:

builtins.fetchGit {
  url = "ssh://git@github.com/nixos/nix.git";
  ref = "master";
}

To verify the commit signature:

builtins.fetchGit {
  url = "ssh://git@github.com/nixos/nix.git";
  verifyCommit = true;
  publicKeys = [
      {
        type = "ssh-ed25519";
        key = "AAAAC3NzaC1lZDI1NTE5AAAAIArPKULJOid8eS6XETwUjO48/HKBWl7FTCK0Z//fplDi";
      }
  ];
}

Nix will refetch the branch according to the tarball-ttl setting.

This behavior is disabled in pure evaluation mode.

To fetch the content of a checked-out work directory:

        builtins.fetchGit ./work-dir

    If the URL points to a local directory, and no ref or rev is given, fetchGit will use the current content of the checked-out files, even if they are not committed or added to Git's index. It will only consider files added to the Git repository, as listed by git ls-files.
fetchTarball args

    Download the specified URL, unpack it and return the path of the unpacked tree. The file must be a tape archive (.tar) compressed with gzip, bzip2 or xz. If the tarball consists of a single directory, then the top-level path component of the files in the tarball is removed. The typical use of the function is to obtain external Nix expression dependencies, such as a particular version of Nixpkgs, e.g.

with import (fetchTarball https://github.com/NixOS/nixpkgs/archive/nixos-14.12.tar.gz) {};

stdenv.mkDerivation { … }

The fetched tarball is cached for a certain amount of time (1 hour by default) in ~/.cache/nix/tarballs/. You can change the cache timeout either on the command line with --tarball-ttl number-of-seconds or in the Nix configuration file by adding the line tarball-ttl = number-of-seconds.

Note that when obtaining the hash with nix-prefetch-url the option --unpack is required.

This function can also verify the contents against a hash. In that case, the function takes a set instead of a URL. The set requires the attribute url and the attribute sha256, e.g.

    with import (fetchTarball {
      url = "https://github.com/NixOS/nixpkgs/archive/nixos-14.12.tar.gz";
      sha256 = "1jppksrfvbk5ypiqdz4cddxdl8z6zyzdb2srq8fcffr327ld5jj2";
    }) {};

    stdenv.mkDerivation { … }

    Not available in restricted evaluation mode.
fetchTree input

        Note

        This function is only available if the fetch-tree experimental feature is enabled.

        For example, include the following in nix.conf:

    extra-experimental-features = fetch-tree

Fetch a file system tree or a plain file using one of the supported backends and return an attribute set with:

    the resulting fixed-output store path
    the corresponding NAR hash
    backend-specific metadata (currently not documented).

input must be an attribute set with the following attributes:

    type (String, required)

    One of the supported source types. This determines other required and allowed input attributes.

    narHash (String, optional)

    The narHash parameter can be used to substitute the source of the tree. It also allows for verification of tree contents that may not be provided by the underlying transfer mechanism. If narHash is set, the source is first looked up is the Nix store and substituters, and only fetched if not available.

A subset of the output attributes of fetchTree can be re-used for subsequent calls to fetchTree to produce the same result again. That is, fetchTree is idempotent.

Downloads are cached in $XDG_CACHE_HOME/nix. The remote source will be fetched from the network if both are true:

    A NAR hash is supplied and the corresponding store path is not valid, that is, not available in the store

        Note

        Substituters are not used in fetching.

    There is no cache entry or the cache entry is older than tarball-ttl

Source types

The following source types and associated input attributes are supported.

    "file"

    Place a plain file into the Nix store. This is similar to builtins.fetchurl

        url (String, required)

        Supported protocols:

            https

                Example

    fetchTree {
      type = "file";
      url = "https://example.com/index.html";
    }

http

Insecure HTTP transfer for legacy sources.

    Warning

    HTTP performs no encryption or authentication. Use a narHash known in advance to ensure the output has expected contents.

file

A file on the local file system.

    Example

            fetchTree {
              type = "file";
              url = "file:///home/eelco/nix/README.md";
            }

"tarball"

Download a tar archive and extract it into the Nix store. This has the same underyling implementation as builtins.fetchTarball

    url (String, required)

        Example

        fetchTree {
          type = "tarball";
          url = "https://github.com/NixOS/nixpkgs/tarball/nixpkgs-23.11";
        }

"git"

Fetch a Git tree and copy it to the Nix store. This is similar to builtins.fetchGit.

    url (String, required)

    The URL formats supported are the same as for Git itself.

        Example

            fetchTree {
              type = "git";
              url = "git@github.com:NixOS/nixpkgs.git";
            }

            Note

            If the URL points to a local directory, and no ref or rev is given, Nix will only consider files added to the Git index, as listed by git ls-files but use the current file contents of the Git working directory.

        ref (String, optional)

        By default, this has no effect. This becomes relevant only once shallow cloning is disabled.

        A Git reference, such as a branch or tag name.

        Default: "HEAD"

        rev (String, optional)

        A Git revision; a commit hash.

        Default: the tip of ref

        shallow (Bool, optional)

        Make a shallow clone when fetching the Git tree. When this is enabled, the options ref and allRefs have no effect anymore.

        Default: true

        submodules (Bool, optional)

        Also fetch submodules if available.

        Default: false

        allRefs (Bool, optional)

        By default, this has no effect. This becomes relevant only once shallow cloning is disabled.

        Whether to fetch all references (eg. branches and tags) of the repository. With this argument being true, it's possible to load a rev from any ref. (Without setting this option, only revs from the specified ref are supported).

        Default: false

        lastModified (Integer, optional)

        Unix timestamp of the fetched commit.

        If set, pass through the value to the output attribute set. Otherwise, generated from the fetched Git tree.

        revCount (Integer, optional)

        Number of revisions in the history of the Git repository before the fetched commit.

        If set, pass through the value to the output attribute set. Otherwise, generated from the fetched Git tree.

The following input types are still subject to change:

    "path"
    "github"
    "gitlab"
    "sourcehut"
    "mercurial"

input can also be a URL-like reference. The additional input types and the URL-like syntax requires the flakes experimental feature to be enabled.

    Example

    Fetch a GitHub repository using the attribute set representation:

builtins.fetchTree {
  type = "github";
  owner = "NixOS";
  repo = "nixpkgs";
  rev = "ae2e6b3958682513d28f7d633734571fb18285dd";
}

This evaluates to the following attribute set:

    {
      lastModified = 1686503798;
      lastModifiedDate = "20230611171638";
      narHash = "sha256-rA9RqKP9OlBrgGCPvfd5HVAXDOy8k2SmPtB/ijShNXc=";
      outPath = "/nix/store/l5m6qlvfs9sdw14ja3qbzpglcjlb6j1x-source";
      rev = "ae2e6b3958682513d28f7d633734571fb18285dd";
      shortRev = "ae2e6b3";
    }

    Example

    Fetch the same GitHub repository using the URL-like syntax:

        builtins.fetchTree "github:NixOS/nixpkgs/ae2e6b3958682513d28f7d633734571fb18285dd"

fetchurl arg

    Download the specified URL and return the path of the downloaded file. arg can be either a string denoting the URL, or an attribute set with the following attributes:

        url

        The URL of the file to download.

        name (default: the last path component of the URL)

        A name for the file in the store. This can be useful if the URL has any characters that are invalid for the store.

    Not available in restricted evaluation mode.
filter f list

    Return a list consisting of the elements of list for which the function f returns true.
filterSource e1 e2

        Warning

        filterSource should not be used to filter store paths. Since filterSource uses the name of the input directory while naming the output directory, doing so will produce a directory name in the form of <hash2>-<hash>-<name>, where <hash>-<name> is the name of the input directory. Since <hash> depends on the unfiltered directory, the name of the output directory will indirectly depend on files that are filtered out by the function. This will trigger a rebuild even when a filtered out file is changed. Use builtins.path instead, which allows specifying the name of the output directory.

    This function allows you to copy sources into the Nix store while filtering certain files. For instance, suppose that you want to use the directory source-dir as an input to a Nix expression, e.g.

stdenv.mkDerivation {
  ...
  src = ./source-dir;
}

However, if source-dir is a Subversion working copy, then all those annoying .svn subdirectories will also be copied to the store. Worse, the contents of those directories may change a lot, causing lots of spurious rebuilds. With filterSource you can filter out the .svn directories:

    src = builtins.filterSource
      (path: type: type != "directory" || baseNameOf path != ".svn")
      ./source-dir;

    Thus, the first argument e1 must be a predicate function that is called for each regular file, directory or symlink in the source tree e2. If the function returns true, the file is copied to the Nix store, otherwise it is omitted. The function is called with two arguments. The first is the full path of the file. The second is a string that identifies the type of the file, which is either "regular", "directory", "symlink" or "unknown" (for other kinds of files such as device nodes or fifos — but note that those cannot be copied to the Nix store, so if the predicate returns true for them, the copy will fail). If you exclude a directory, the entire corresponding subtree of e2 will be excluded.
findFile search-path lookup-path

    Find lookup-path in search-path.

    Lookup path expressions are desugared using this and builtins.nixPath:

<nixpkgs>

is equivalent to:

builtins.findFile builtins.nixPath "nixpkgs"

A search path is represented as a list of attribute sets with two attributes:

    prefix is a relative path.
    path denotes a file system location

Examples of search path attribute sets:

{
  prefix = "";
  path = "/nix/var/nix/profiles/per-user/root/channels";
}

{
  prefix = "nixos-config";
  path = "/etc/nixos/configuration.nix";
}

{
  prefix = "nixpkgs";
  path = "https://github.com/NixOS/nixpkgs/tarballs/master";
}

{
  prefix = "nixpkgs";
  path = "channel:nixpkgs-unstable";
}

    {
      prefix = "flake-compat";
      path = "flake:github:edolstra/flake-compat";
    }

The lookup algorithm checks each entry until a match is found, returning a path value of the match:

    If a prefix of lookup-path matches prefix, then the remainder of lookup-path (the "suffix") is searched for within the directory denoted by path. The contents of path may need to be downloaded at this point to look inside.

    If the suffix is found inside that directory, then the entry is a match. The combined absolute path of the directory (now downloaded if need be) and the suffix is returned.

    Example

    A search-path value

    [
      {
        prefix = "";
        path = "/home/eelco/Dev";
      }
      {
        prefix = "nixos-config";
        path = "/etc/nixos";
      }
    ]

    and a lookup-path value "nixos-config" will cause Nix to try /home/eelco/Dev/nixos-config and /etc/nixos in that order and return the first path that exists.

If path starts with http:// or https://, it is interpreted as the URL of a tarball that will be downloaded and unpacked to a temporary location. The tarball must consist of a single top-level directory.

The URLs of the tarballs from the official nixos.org channels can be abbreviated as channel:<channel-name>. See documentation on nix-channel for details about channels.

    Example

    These two search path entries are equivalent:

{
  prefix = "nixpkgs";
  path = "channel:nixpkgs-unstable";
}

        {
          prefix = "nixpkgs";
          path = "https://nixos.org/channels/nixos-unstable/nixexprs.tar.xz";
        }

Search paths can also point to source trees using flake URLs.

    Example

    The search path entry

{
  prefix = "nixpkgs";
  path = "flake:nixpkgs";
}

specifies that the prefix nixpkgs shall refer to the source tree downloaded from the nixpkgs entry in the flake registry.

Similarly

        {
          prefix = "nixpkgs";
          path = "flake:github:nixos/nixpkgs/nixos-22.05";
        }

        makes <nixpkgs> refer to a particular branch of the NixOS/nixpkgs repository on GitHub.

flakeRefToString attrs

        Note

        This function is only available if the flakes experimental feature is enabled.

        For example, include the following in nix.conf:

    extra-experimental-features = flakes

Convert a flake reference from attribute set format to URL format.

For example:

builtins.flakeRefToString {
  dir = "lib"; owner = "NixOS"; ref = "23.05"; repo = "nixpkgs"; type = "github";
}

evaluates to

    "github:NixOS/nixpkgs/23.05?dir=lib"

floor double

    Converts an IEEE-754 double-precision floating-point number (double) to the next lower integer.

    If the datatype is neither an integer nor a "float", an evaluation error will be thrown.
foldl' op nul list

    Reduce a list by applying a binary operator, from left to right, e.g. foldl' op nul [x0 x1 x2 ...] = op (op (op nul x0) x1) x2) ....

    For example, foldl' (acc: elem: acc + elem) 0 [1 2 3] evaluates to 6 and foldl' (acc: elem: { "${elem}" = elem; } // acc) {} ["a" "b"] evaluates to { a = "a"; b = "b"; }.

    The first argument of op is the accumulator whereas the second argument is the current element being processed. The return value of each application of op is evaluated immediately, even for intermediate values.
fromJSON e

    Convert a JSON string to a Nix value. For example,

    builtins.fromJSON ''{"x": [1, 2, 3], "y": null}''

    returns the value { x = [ 1 2 3 ]; y = null; }.
fromTOML e

    Convert a TOML string to a Nix value. For example,

    builtins.fromTOML ''
      x=1
      s="a"
      [table]
      y=2
    ''

    returns the value { s = "a"; table = { y = 2; }; x = 1; }.
functionArgs f

    Return a set containing the names of the formal arguments expected by the function f. The value of each attribute is a Boolean denoting whether the corresponding argument has a default value. For instance, functionArgs ({ x, y ? 123}: ...) = { x = false; y = true; }.

    "Formal argument" here refers to the attributes pattern-matched by the function. Plain lambdas are not included, e.g. functionArgs (x: ...) = { }.
genList generator length

    Generate list of size length, with each element i equal to the value returned by generator i. For example,

    builtins.genList (x: x * x) 5

    returns the list [ 0 1 4 9 16 ].
genericClosure attrset

    builtins.genericClosure iteratively computes the transitive closure over an arbitrary relation defined by a function.

    It takes attrset with two attributes named startSet and operator, and returns a list of attribute sets:

        startSet: The initial list of attribute sets.

        operator: A function that takes an attribute set and returns a list of attribute sets. It defines how each item in the current set is processed and expanded into more items.

    Each attribute set in the list startSet and the list returned by operator must have an attribute key, which must support equality comparison. The value of key can be one of the following types:

        Int
        Float
        Boolean
        String
        Path
        List

    The result is produced by calling the operator on each item that has not been called yet, including newly added items, until no new items are added. Items are compared by their key attribute.

    Common usages are:

        Generating unique collections of items, such as dependency graphs.
        Traversing through structures that may contain cycles or loops.
        Processing data structures with complex internal relationships.

        Example

builtins.genericClosure {
  startSet = [ {key = 5;} ];
  operator = item: [{
    key = if (item.key / 2 ) * 2 == item.key
         then item.key / 2
         else 3 * item.key + 1;
  }];
}

evaluates to

        [ { key = 5; } { key = 16; } { key = 8; } { key = 4; } { key = 2; } { key = 1; } ]

getAttr s set

    getAttr returns the attribute named s from set. Evaluation aborts if the attribute doesn’t exist. This is a dynamic version of the . operator, since s is an expression rather than an identifier.
getContext s

    Return the string context of s.

    The string context tracks references to derivations within a string. It is represented as an attribute set of store derivation paths mapping to output names.

    Using string interpolation on a derivation will add that derivation to the string context. For example,

builtins.getContext "${derivation { name = "a"; builder = "b"; system = "c"; }}"

evaluates to

    { "/nix/store/arhvjaf6zmlyn8vh8fgn55rpwnxq0n7l-a.drv" = { outputs = [ "out" ]; }; }

getEnv s

    getEnv returns the value of the environment variable s, or an empty string if the variable doesn’t exist. This function should be used with care, as it can introduce all sorts of nasty environment dependencies in your Nix expression.

    getEnv is used in Nix Packages to locate the file ~/.nixpkgs/config.nix, which contains user-local settings for Nix Packages. (That is, it does a getEnv "HOME" to locate the user’s home directory.)
getFlake args

        Note

        This function is only available if the flakes experimental feature is enabled.

        For example, include the following in nix.conf:

    extra-experimental-features = flakes

Fetch a flake from a flake reference, and return its output attributes and some metadata. For example:

(builtins.getFlake "nix/55bc52401966fbffa525c574c14f67b00bc4fb3a").packages.x86_64-linux.nix

Unless impure evaluation is allowed (--impure), the flake reference must be "locked", e.g. contain a Git revision or content hash. An example of an unlocked usage is:

    (builtins.getFlake "github:edolstra/dwarffs").rev

groupBy f list

    Groups elements of list together by the string returned from the function f called on each element. It returns an attribute set where each attribute value contains the elements of list that are mapped to the same corresponding attribute name returned by f.

    For example,

builtins.groupBy (builtins.substring 0 1) ["foo" "bar" "baz"]

evaluates to

    { b = [ "bar" "baz" ]; f = [ "foo" ]; }

hasAttr s set

    hasAttr returns true if set has an attribute named s, and false otherwise. This is a dynamic version of the ? operator, since s is an expression rather than an identifier.
hasContext s

    Return true if string s has a non-empty context. The context can be obtained with getContext.

        Example

        Many operations require a string context to be empty because they are intended only to work with "regular" strings, and also to help users avoid unintentionally loosing track of string context elements. builtins.hasContext can help create better domain-specific errors in those case.

        name: meta:

        if builtins.hasContext name
        then throw "package name cannot contain string context"
        else { ${name} = meta; }

hashFile type p

    Return a base-16 representation of the cryptographic hash of the file at path p. The hash algorithm specified by type must be one of "md5", "sha1", "sha256" or "sha512".
hashString type s

    Return a base-16 representation of the cryptographic hash of string s. The hash algorithm specified by type must be one of "md5", "sha1", "sha256" or "sha512".
head list

    Return the first element of a list; abort evaluation if the argument isn’t a list or is an empty list. You can test whether a list is empty by comparing it with [].
import path

    Load, parse, and return the Nix expression in the file path.

        Note

        Unlike some languages, import is a regular function in Nix.

    The path argument must meet the same criteria as an interpolated expression.

    If path is a directory, the file default.nix in that directory is used if it exists.

        Example

 echo 123 > default.nix

Import default.nix from the current directory.

import ./.

    123

Evaluation aborts if the file doesn’t exist or contains an invalid Nix expression.

A Nix expression loaded by import must not contain any free variables, that is, identifiers that are not defined in the Nix expression itself and are not built-in. Therefore, it cannot refer to variables that are in scope at the call site.

    Example

    If you have a calling expression

rec {
  x = 123;
  y = import ./foo.nix;
}

then the following foo.nix will give an error:

# foo.nix
x + 456

since x is not in scope in foo.nix. If you want x to be available in foo.nix, pass it as a function argument:

rec {
  x = 123;
  y = import ./foo.nix x;
}

and

        # foo.nix
        x: x + 456

        The function argument doesn’t have to be called x in foo.nix; any name would work.

intersectAttrs e1 e2

    Return a set consisting of the attributes in the set e2 which have the same name as some attribute in e1.

    Performs in O(n log m) where n is the size of the smaller set and m the larger set's size.
isAttrs e

    Return true if e evaluates to a set, and false otherwise.
isBool e

    Return true if e evaluates to a bool, and false otherwise.
isFloat e

    Return true if e evaluates to a float, and false otherwise.
isFunction e

    Return true if e evaluates to a function, and false otherwise.
isInt e

    Return true if e evaluates to an integer, and false otherwise.
isList e

    Return true if e evaluates to a list, and false otherwise.
isNull e

    Return true if e evaluates to null, and false otherwise.

    This is equivalent to e == null.
isPath e

    Return true if e evaluates to a path, and false otherwise.
isString e

    Return true if e evaluates to a string, and false otherwise.
langVersion (integer)

    The current version of the Nix language.
length e

    Return the length of the list e.
lessThan e1 e2

    Return true if the number e1 is less than the number e2, and false otherwise. Evaluation aborts if either e1 or e2 does not evaluate to a number.
listToAttrs e

    Construct a set from a list specifying the names and values of each attribute. Each element of the list should be a set consisting of a string-valued attribute name specifying the name of the attribute, and an attribute value specifying its value.

    In case of duplicate occurrences of the same name, the first takes precedence.

    Example:

builtins.listToAttrs
  [ { name = "foo"; value = 123; }
    { name = "bar"; value = 456; }
    { name = "bar"; value = 420; }
  ]

evaluates to

    { foo = 123; bar = 456; }

map f list

    Apply the function f to each element in the list list. For example,

    map (x: "foo" + x) [ "bar" "bla" "abc" ]

    evaluates to [ "foobar" "foobla" "fooabc" ].
mapAttrs f attrset

    Apply function f to every element of attrset. For example,

    builtins.mapAttrs (name: value: value * 10) { a = 1; b = 2; }

    evaluates to { a = 10; b = 20; }.
match regex str

    Returns a list if the extended POSIX regular expression regex matches str precisely, otherwise returns null. Each item in the list is a regex group.

builtins.match "ab" "abc"

Evaluates to null.

builtins.match "abc" "abc"

Evaluates to [ ].

builtins.match "a(b)(c)" "abc"

Evaluates to [ "b" "c" ].

    builtins.match "[[:space:]]+([[:upper:]]+)[[:space:]]+" "  FOO   "

    Evaluates to [ "FOO" ].
mul e1 e2

    Return the product of the numbers e1 and e2.
nixPath (list)

    The value of the nix-path configuration setting: a list of search path entries used to resolve lookup paths.

        Example

    $ NIX_PATH= nix-instantiate --eval --expr "builtins.nixPath" -I foo=bar --no-pure-eval
    [ { path = "bar"; prefix = "foo"; } ]

Lookup path expressions are desugared using this and builtins.findFile:

<nixpkgs>

is equivalent to:

    builtins.findFile builtins.nixPath "nixpkgs"

nixVersion (string)

    The version of Nix.

    For example, where the command line returns the current Nix version,

$ nix --version
nix (Nix) 2.16.0

the Nix language evaluator returns the same value:

    nix-repl> builtins.nixVersion
    "2.16.0"

null (null)

    Primitive value.

    The name null is not special, and can be shadowed:

    nix-repl> let null = 1; in null
    1

outputOf derivation-reference output-name

        Note

        This function is only available if the dynamic-derivations experimental feature is enabled.

        For example, include the following in nix.conf:

    extra-experimental-features = dynamic-derivations

Return the output path of a derivation, literally or using a placeholder if needed.

If the derivation has a statically-known output path (i.e. the derivation output is input-addressed, or fixed content-addresed), the output path will just be returned. But if the derivation is content-addressed or if the derivation is itself not-statically produced (i.e. is the output of another derivation), a placeholder will be returned instead.

derivation reference must be a string that may contain a regular store path to a derivation, or may be a placeholder reference. If the derivation is produced by a derivation, you must explicitly select drv.outPath. This primop can be chained arbitrarily deeply. For instance,

    builtins.outputOf
      (builtins.outputOf myDrv "out")
      "out"

    will return a placeholder for the output of the output of myDrv.

    This primop corresponds to the ^ sigil for derivable paths, e.g. as part of installable syntax on the command line.
parseDrvName s

    Split the string s into a package name and version. The package name is everything up to but not including the first dash not followed by a letter, and the version is everything following that dash. The result is returned in a set { name, version }. Thus, builtins.parseDrvName "nix-0.12pre12876" returns { name = "nix"; version = "0.12pre12876"; }.
parseFlakeRef flake-ref

        Note

        This function is only available if the flakes experimental feature is enabled.

        For example, include the following in nix.conf:

    extra-experimental-features = flakes

Parse a flake reference, and return its exploded form.

For example:

builtins.parseFlakeRef "github:NixOS/nixpkgs/23.05?dir=lib"

evaluates to:

    { dir = "lib"; owner = "NixOS"; ref = "23.05"; repo = "nixpkgs"; type = "github"; }

partition pred list

    Given a predicate function pred, this function returns an attrset containing a list named right, containing the elements in list for which pred returned true, and a list named wrong, containing the elements for which it returned false. For example,

builtins.partition (x: x > 10) [1 23 9 3 42]

evaluates to

    { right = [ 23 42 ]; wrong = [ 1 9 3 ]; }

path args

    An enrichment of the built-in path type, based on the attributes present in args. All are optional except path:

        path
        The underlying path.

        name
        The name of the path when added to the store. This can used to reference paths that have nix-illegal characters in their names, like @.

        filter
        A function of the type expected by builtins.filterSource, with the same semantics.

        recursive
        When false, when path is added to the store it is with a flat hash, rather than a hash of the NAR serialization of the file. Thus, path must refer to a regular file, not a directory. This allows similar behavior to fetchurl. Defaults to true.

        sha256
        When provided, this is the expected hash of the file at the path. Evaluation will fail if the hash is incorrect, and providing a hash allows builtins.path to be used even when the pure-eval nix config option is on.

pathExists path

    Return true if the path path exists at evaluation time, and false otherwise.
placeholder output

    Return a placeholder string for the specified output that will be substituted by the corresponding output path at build time. Typical outputs would be "out", "bin" or "dev".
readDir path

    Return the contents of the directory path as a set mapping directory entries to the corresponding file type. For instance, if directory A contains a regular file B and another directory C, then builtins.readDir ./A will return the set

    { B = "regular"; C = "directory"; }

    The possible values for the file type are "regular", "directory", "symlink" and "unknown".
readFile path

    Return the contents of the file path as a string.
readFileType p

    Determine the directory entry type of a filesystem node, being one of "directory", "regular", "symlink", or "unknown".
removeAttrs set list

    Remove the attributes listed in list from set. The attributes don’t have to exist in set. For instance,

    removeAttrs { x = 1; y = 2; z = 3; } [ "a" "x" "z" ]

    evaluates to { y = 2; }.
replaceStrings from to s

    Given string s, replace every occurrence of the strings in from with the corresponding string in to.

    The argument to is lazy, that is, it is only evaluated when its corresponding pattern in from is matched in the string s

    Example:

    builtins.replaceStrings ["oo" "a"] ["a" "i"] "foobar"

    evaluates to "fabir".
seq e1 e2

    Evaluate e1, then evaluate and return e2. This ensures that a computation is strict in the value of e1.
sort comparator list

    Return list in sorted order. It repeatedly calls the function comparator with two elements. The comparator should return true if the first element is less than the second, and false otherwise. For example,

    builtins.sort builtins.lessThan [ 483 249 526 147 42 77 ]

    produces the list [ 42 77 147 249 483 526 ].

    This is a stable sort: it preserves the relative order of elements deemed equal by the comparator.
split regex str

    Returns a list composed of non matched strings interleaved with the lists of the extended POSIX regular expression regex matches of str. Each item in the lists of matched sequences is a regex group.

builtins.split "(a)b" "abc"

Evaluates to [ "" [ "a" ] "c" ].

builtins.split "([ac])" "abc"

Evaluates to [ "" [ "a" ] "b" [ "c" ] "" ].

builtins.split "(a)|(c)" "abc"

Evaluates to [ "" [ "a" null ] "b" [ null "c" ] "" ].

    builtins.split "([[:upper:]]+)" " FOO "

    Evaluates to [ " " [ "FOO" ] " " ].
splitVersion s

    Split a string representing a version into its components, by the same version splitting logic underlying the version comparison in nix-env -u.
storeDir (string)

    Logical file system location of the Nix store currently in use.

    This value is determined by the store parameter in Store URLs:

    $ nix-instantiate --store 'dummy://?store=/blah' --eval --expr builtins.storeDir
    "/blah"

storePath path

    This function allows you to define a dependency on an already existing store path. For example, the derivation attribute src = builtins.storePath /nix/store/f1d18v1y…-source causes the derivation to depend on the specified path, which must exist or be substitutable. Note that this differs from a plain path (e.g. src = /nix/store/f1d18v1y…-source) in that the latter causes the path to be copied again to the Nix store, resulting in a new path (e.g. /nix/store/ld01dnzc…-source-source).

    Not available in pure evaluation mode.

    See also builtins.fetchClosure.
stringLength e

    Return the number of bytes of the string e. If e is not a string, evaluation is aborted.
sub e1 e2

    Return the difference between the numbers e1 and e2.
substring start len s

    Return the substring of s from character position start (zero-based) up to but not including start + len. If start is greater than the length of the string, an empty string is returned. If start + len lies beyond the end of the string or len is -1, only the substring up to the end of the string is returned. start must be non-negative. For example,

    builtins.substring 0 3 "nixos"

    evaluates to "nix".
tail list

    Return the list without its first item; abort evaluation if the argument isn’t a list or is an empty list.

        Warning

        This function should generally be avoided since it's inefficient: unlike Haskell's tail, it takes O(n) time, so recursing over a list by repeatedly calling tail takes O(n^2) time.

throw s

    Throw an error message s. This usually aborts Nix expression evaluation, but in nix-env -qa and other commands that try to evaluate a set of derivations to get information about those derivations, a derivation that throws an error is silently skipped (which is not the case for abort).
toFile name s

    Store the string s in a file in the Nix store and return its path. The file has suffix name. This file can be used as an input to derivations. One application is to write builders “inline”. For instance, the following Nix expression combines the Nix expression for GNU Hello and its build script into one file:

{ stdenv, fetchurl, perl }:

stdenv.mkDerivation {
  name = "hello-2.1.1";

  builder = builtins.toFile "builder.sh" "
    source $stdenv/setup

    PATH=$perl/bin:$PATH

    tar xvfz $src
    cd hello-*
    ./configure --prefix=$out
    make
    make install
  ";

  src = fetchurl {
    url = "http://ftp.nluug.nl/pub/gnu/hello/hello-2.1.1.tar.gz";
    sha256 = "1md7jsfd8pa45z73bz1kszpp01yw6x5ljkjk2hx7wl800any6465";
  };
  inherit perl;
}

It is even possible for one file to refer to another, e.g.,

builder = let
  configFile = builtins.toFile "foo.conf" "
    # This is some dummy configuration file.
    ...
  ";
in builtins.toFile "builder.sh" "
  source $stdenv/setup
  ...
  cp ${configFile} $out/etc/foo.conf
";

Note that ${configFile} is a string interpolation, so the result of the expression configFile (i.e., a path like /nix/store/m7p7jfny445k...-foo.conf) will be spliced into the resulting string.

It is however not allowed to have files mutually referring to each other, like so:

    let
      foo = builtins.toFile "foo" "...${bar}...";
      bar = builtins.toFile "bar" "...${foo}...";
    in foo

    This is not allowed because it would cause a cyclic dependency in the computation of the cryptographic hashes for foo and bar.

    It is also not possible to reference the result of a derivation. If you are using Nixpkgs, the writeTextFile function is able to do that.
toJSON e

    Return a string containing a JSON representation of e. Strings, integers, floats, booleans, nulls and lists are mapped to their JSON equivalents. Sets (except derivations) are represented as objects. Derivations are translated to a JSON string containing the derivation’s output path. Paths are copied to the store and represented as a JSON string of the resulting store path.
toPath s

    DEPRECATED. Use /. + "/path" to convert a string into an absolute path. For relative paths, use ./. + "/path".
toString e

    Convert the expression e to a string. e can be:

        A string (in which case the string is returned unmodified).

        A path (e.g., toString /foo/bar yields "/foo/bar".

        A set containing { __toString = self: ...; } or { outPath = ...; }.

        An integer.

        A list, in which case the string representations of its elements are joined with spaces.

        A Boolean (false yields "", true yields "1").

        null, which yields the empty string.

toXML e

    Return a string containing an XML representation of e. The main application for toXML is to communicate information with the builder in a more structured format than plain environment variables.

    Here is an example where this is the case:

{ stdenv, fetchurl, libxslt, jira, uberwiki }:

stdenv.mkDerivation (rec {
  name = "web-server";

  buildInputs = [ libxslt ];

  builder = builtins.toFile "builder.sh" "
    source $stdenv/setup
    mkdir $out
    echo "$servlets" | xsltproc ${stylesheet} - > $out/server-conf.xml ①
  ";

  stylesheet = builtins.toFile "stylesheet.xsl" ②
   "<?xml version='1.0' encoding='UTF-8'?>
    <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>
      <xsl:template match='/'>
        <Configure>
          <xsl:for-each select='/expr/list/attrs'>
            <Call name='addWebApplication'>
              <Arg><xsl:value-of select=\"attr[@name = 'path']/string/@value\" /></Arg>
              <Arg><xsl:value-of select=\"attr[@name = 'war']/path/@value\" /></Arg>
            </Call>
          </xsl:for-each>
        </Configure>
      </xsl:template>
    </xsl:stylesheet>
  ";

  servlets = builtins.toXML [ ③
    { path = "/bugtracker"; war = jira + "/lib/atlassian-jira.war"; }
    { path = "/wiki"; war = uberwiki + "/uberwiki.war"; }
  ];
})

The builder is supposed to generate the configuration file for a Jetty servlet container. A servlet container contains a number of servlets (*.war files) each exported under a specific URI prefix. So the servlet configuration is a list of sets containing the path and war of the servlet (①). This kind of information is difficult to communicate with the normal method of passing information through an environment variable, which just concatenates everything together into a string (which might just work in this case, but wouldn’t work if fields are optional or contain lists themselves). Instead the Nix expression is converted to an XML representation with toXML, which is unambiguous and can easily be processed with the appropriate tools. For instance, in the example an XSLT stylesheet (at point ②) is applied to it (at point ①) to generate the XML configuration file for the Jetty server. The XML representation produced at point ③ by toXML is as follows:


    <expr>
      <list>
        <attrs>
          <attr name="path">
            <string value="/bugtracker" />
          </attr>
          <attr name="war">
            <path value="/nix/store/d1jh9pasa7k2...-jira/lib/atlassian-jira.war" />
          </attr>
        </attrs>
        <attrs>
          <attr name="path">
            <string value="/wiki" />
          </attr>
          <attr name="war">
            <path value="/nix/store/y6423b1yi4sx...-uberwiki/uberwiki.war" />
          </attr>
        </attrs>
      </list>
    </expr>

    Note that we used the toFile built-in to write the builder and the stylesheet “inline” in the Nix expression. The path of the stylesheet is spliced into the builder using the syntax xsltproc ${stylesheet}.
trace e1 e2

    Evaluate e1 and print its abstract syntax representation on standard error. Then return e2. This function is useful for debugging.

    If the debugger-on-trace option is set to true and the --debugger flag is given, the interactive debugger will be started when trace is called (like break).
traceVerbose e1 e2

    Evaluate e1 and print its abstract syntax representation on standard error if --trace-verbose is enabled. Then return e2. This function is useful for debugging.
true (Boolean)

    Primitive value.

    It can be returned by comparison operators and used in conditional expressions.

    The name true is not special, and can be shadowed:

    nix-repl> let true = 1; in true
    1

tryEval e

    Try to shallowly evaluate e. Return a set containing the attributes success (true if e evaluated successfully, false if an error was thrown) and value, equalling e if successful and false otherwise. tryEval will only prevent errors created by throw or assert from being thrown. Errors tryEval will not catch are for example those created by abort and type errors generated by builtins. Also note that this doesn't evaluate e deeply, so let e = { x = throw ""; }; in (builtins.tryEval e).success will be true. Using builtins.deepSeq one can get the expected result: let e = { x = throw ""; }; in (builtins.tryEval (builtins.deepSeq e e)).success will be false.
typeOf e

    Return a string representing the type of the value e, namely "int", "bool", "string", "path", "null", "set", "list", "lambda" or "float".
unsafeDiscardOutputDependency s

    Create a copy of the given string where every derivation deep string context element is turned into a constant string context element.

    This is the opposite of builtins.addDrvOutputDependencies.

    This is unsafe because it allows us to "forget" store objects we would have otherwise refered to with the string context, whereas Nix normally tracks all dependencies consistently. Safe operations "grow" but never "shrink" string contexts. builtins.addDrvOutputDependencies in contrast is safe because "derivation deep" string context element always refers to the underlying derivation (among many more things). Replacing a constant string context element with a "derivation deep" element is a safe operation that just enlargens the string context without forgetting anything.
unsafeDiscardStringContext s

    Discard the string context from a value that can be coerced to a string.
warn e1 e2

    Evaluate e1, which must be a string and print iton standard error as a warning. Then return e2. This function is useful for non-critical situations where attention is advisable.

    If the debugger-on-trace or debugger-on-warn option is set to true and the --debugger flag is given, the interactive debugger will be started when warn is called (like break).

    If the abort-on-warn option is set, the evaluation will be aborted after the warning is printed. This is useful to reveal the stack trace of the warning, when the context is non-interactive and a debugger can not be launched.
zipAttrsWith f list

    Transpose a list of attribute sets into an attribute set of lists, then apply mapAttrs.

    f receives two arguments: the attribute name and a non-empty list of all values encountered for that attribute name.

    The result is an attribute set where the attribute names are the union of the attribute names in each element of list. The attribute values are the return values of f.

builtins.zipAttrsWith
  (name: values: { inherit name values; })
  [ { a = "x"; } { a = "y"; b = "z"; } ]

evaluates to

    {
      a = { name = "a"; values = [ "x" "y" ]; };
      b = { name = "b"; values = [ "z" ]; };
    }












importer.nix 

{lib, ...}@inputset: dir:

let

  inherit (lib.attrsets) setAttrByPath hasAttrByPath;
  importLooper = (import ./importLooper.nix) inputset;

  mkAPath = list:
    {
      inherit list;
      last = lib.lists.last list;
      setVal = setAttrByPath list;
      readAttr = attr: defval: hasAttrByPath (list ++ [attr]) defval modules; 
      readEnable = hasAttrByPath (list ++ ["enable"]) false modules; 


      #addOption = # eg. mkHome {...} |> addOption 
    # optionPath =
    # configPath = 
    };


  importFunction = path: importerPath:
    let
      importerAPath = mkAPath importerPath;
    in 
    import path (
      {
        inherit importerAPath modules mkAPath;
      } 
      // inputset // 
      ((import ./importerFunctions) inputset//{inherit importerAPath modules mkAPath;})  
    );

  modules = importLooper dir importFunction;
in
  modules



importLooper.nix

{lib, ...}: dir: importFunction:
  let

    inherit (builtins) attrNames readDir readFileType isPath baseNameOf toString;
    inherit (lib.strings) hasSuffix removeSuffix;
    inherit (lib.filesystem) pathIsDirectory;


    itemParser = importFunction: {fileODirName, oldPath, oldImporterPath}:
      let
        path = lib.path.append oldPath fileODirName;

        isDir = pathIsDirectory path;
        isNix = hasSuffix ".nix" (toString path);
        isDef = fileODirName == "default.nix";

        parseNix = 
          let
            name = removeSuffix ".nix" fileODirName;
            #updateSet
            importerPath = oldImporterPath ++ [name];
          in
            importFunction path importerPath;

        parseDef = importFunction path oldImporterPath;

        doLoop = 
          let
            name = fileODirName;
            #updateSet
            importerPath = oldImporterPath ++ [name];
          in
            builtins.foldl'
              ( set: item:
                lib.recursiveUpdate # https://nix.dev/guides/best-practices.html#updating-nested-attribute-sets
                  (itemParser importFunction { 
                    fileODirName = item;
                    oldPath = path;
                    oldImporterPath = importerPath; 
                  })
                  set
              ) 
              {} 
              (attrNames (readDir path))
            ;
      in
        if isDir
        then doLoop
        else (
          if isDef
          then parseDef
          else (
            if isNix
            then parseNix
            else {}
          )
        );
  in
    if !(isPath dir) 
    then throw "importer needs a nix path"
    else (
      itemParser importFunction { fileODirName = baseNameOf dir; oldPath = ./.; oldImporterPath = [];}
    )








































































































    No. I want to define in my flake.nix:

inputs = { homemanager = ¨"}
outputs = 
let 
  funs = import ./functions;
  nixosConfig = }
in
{

nixosConfigurations = nixosConfig